NoSQL хранилища
Высшая Школа Цифровой Культуры
Университет ИТМО
dc@itmo.ru
Содержание
1 NoSQL 2
1.1 Основы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2 Основные характеристики . . . . . . . . . . . . . . . . . . . . . . 6
1.3 Технологии . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.4 Примеры NoSQL систем . . . . . . . . . . . . . . . . . . . . . . . 15
2 Redis 19
3 MongoDB 25
3.1 Основы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
3.2 Начало работы с MongoDB и управление базами . . . . . . . . . 31
3.3 Выборка данных из коллекций . . . . . . . . . . . . . . . . . . . 37
3.4 Фильтры, сортировка и агрегирование . . . . . . . . . . . . . . . 43
4 Cassandra 53
4.1 Основы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
4.2 Проектирование модели данных . . . . . . . . . . . . . . . . . . 60
Высшая школа цифровой культуры Университет ИТМО
1 NoSQL
1.1 Основы
В предыдущем модуле мы рассмотрели функциональность, которая яв-
ляется общепринятой для систем управления данными, называемых реля-
ционными или традиционными. Однако, в последнее десятилетие наряду с
развитием традиционных систем управления данными появилось новое на-
правление систем с достаточно амбициозным названием NoSQL. Эти систе-
мы позиционируют себя как альтернативные системы хранения, которые в
состоянии хранить и обрабатывать гигантские объемы данных. Из-за боль-
шого разнообразия существующих сегодня NoSQL систем трудно понять, что
они на самом деле собой представляют, и, тем более, дать рекомендации по
использованию их для конкретных прикладных задач. Попробуем описать
это явление подробнее с примерами реально существующих систем. Но нач-
нем с истории.
Происхождение термина NoSQL приписывается Йохану Оскарсону
(Johan Oskarsson), который использовал его на конференции по нереля-
ционным базам данных в 2009 году. Сам термин NoSQL понимается как
<NotOnlySQL>. Термин используется в качестве главной классификации,
подразумевающей большое разнообразие хранилищ данных, многие из ко-
торых не основаны на реляционной модели данных, в том числе узко ориен-
тированных на очень специфические модели данных, например, графы.
Большинство систем NoSQL создавались с расчетом на работу на кла-
стерах из недорогих компьютеров в облачной среде, легкое масштабирование
и хранение слабоструктурированных и не структурированных данных. Раз-
беремся, что стоит за каждым из этих понятий.
Работа на кластерах в облачной средеозначает, что идеологи
NoSQL-систем изначально хотели уменьшить стоимость используемых ресур-
2
Высшая школа цифровой культуры Университет ИТМО
сов и упростить доступ к ним. Для уменьшения стоимости было предложено
разрабатывать NoSQL-системы как распределенные и использовать для хра-
нения и обработки данных кластеры, т.е. группы компьютеров, объединенные
высокоскоростными каналами связи и представляющие с точки зрения поль-
зователей единый аппаратный ресурс.
Легкий доступ к мощностям и ресурсам должны были обеспечивать раз-
нообразные Интернет-сервисы. Очевидно, что поддержка транзакций и стро-
гой согласованности данных в условиях распределенных систем требует зна-
чительного числа синхронных взаимодействий. Однако есть ряд задач, когда
объективно нет необходимости в поддержке транзакций. Например, анали-
тические приложения, в которых нет регулярных обновлений и для которых
информация, поступающая в последние часы, минуты и секунды, не является
существенной. Тем более поддержка транзакций не актуальна для хранения
изображений, видеороликов, файлов и т.п. Именно для такого рода задач в
первую очередь и создавались NoSQL системы.
Масштабируемость – следующий чрезвычайно важный аспект систем
обработки данных, если для них предусматривается сценарий работы под
3
Высшая школа цифровой культуры Университет ИТМО
большой нагрузкой. Систему называютмасштабируемой, если она способна
увеличивать производительность пропорционально дополнительным ресур-
сам.
Масштабируемость принято количественно оценивать через отношение
прироста производительности системы к приросту используемых ресурсов.
Системы, в которых это отношение близко к единице принято называтьлегко
масштабируемыми. Именно это свойство должно учитываться разработчи-
ками NoSQL при выборе архитектуры систем, так как для потенциальных
приложений NoSQL систем характерны сценарии работы с высокой нагруз-
кой.
Последний из упомянутых аспектов –возможность хранения и обра-
ботки в NoSQL системах слабоструктурированных и неструктури-
рованных данных. Напомним, что когда вы собираетесь хранить данные
в реляционной базе, Вы сначала определяете жесткую схему (структуру) ба-
зы данных, т.е. указываете, какие существуют таблицы и столбцы, и задаете
типы данных, которые могут содержаться в этих столбцах.
Неструктурированные или слабоструктурированные данные, напротив,
не требуют обязательного задания схемы данных. Примерами неструктури-
рованных данных могут служить с файлы видео, аудио и изображениями,
содержимое писем и т.п. Типичными примерами данных слабоструктуриро-
ванных форматов являются структуры в форматах XML (eXtensible Markup
Language) и JSON (JavaScriptObjectNotation). На приведенном слайде вы мо-
жете видеть примеры таких слабоструктурированных данных.
В приведенном примере видно, что оба формата представляют одни и те
же данные – о мультфильме Король Лев. Однако правая структура (в форма-
те JSON) более компактна и выразительна. Именно поэтому она чаще других
используется для представления данных в NoSQL системах. Рассмотрим бо-
лееформально,чтособойпредставляетструктураформатаJSON.Структуру
(или документ) формата JSON можно представить как контейнер, состоящий
4
Высшая школа цифровой культуры Университет ИТМО
из элементов. Каждый элемент в таком контейнере – это некоторая струк-
турная единица, состоящая из ключа и значения.
Значение ключа в JSON может быть записано в одном из следующих
форматов: string (строка), number (число), object (объект), array (массив),
boolean (логическое значение true или false), null (специальное значением,
которое указывает на отсутствие значения любого другого типа). На слайде
приведен пример структуры JSON, состоящей из различных типов данных.
Следует обратить внимание на использование специального значения –
null. Если какому-то ключу нет соответствующего значения, то упоминать
соответствующую пару ключ:null можно, но никакой необходимости нет.
В NoSQL хранилищах JSON структуры объединяются в коллекции (ана-
лог таблиц в реляционных базах). Однако в отличие от таблиц в коллекцию
могут объединяться данные различной структуры. Например, следующие две
структуры могут оказаться в одной коллекции, несмотря на то что количе-
ство пар ключ-значение в структурах различается.
5
Высшая школа цифровой культуры Университет ИТМО
1.2 Основные характеристики
NoSQL системы весьма разнообразны и решения, которые они исполь-
зуют, не ограничены никакими формальными рамками. Тем не менее, по-
пытаемся перечислить некоторые характеристики, которые дают основания
хранилищам причислять себя к системам типа NoSQL.
Одно из самых больших заблуждений состоит в том, что наиболее общей
характеристикой всех этих систем является отказ от использования языка
SQL. Это утверждение не соответствует действительности, так как многие
NoSQL системы используют SQL-подобные языки запросов. Хотя надо при-
знать, что в списке NoSQL есть системы, которые, действительно отказались
от использования декларативных запросов и формулируют запросы на язы-
ках низкого уровня.
NoSQL системы используют, как правило, простые и, предназначенные
для широкого круга задач. Современные NoSQL модели данных принято де-
лить на четыре категории, а именно: хранилища типа ключ-значение, доку-
ментные хранилища, колоночные хранилища и граф-ориентированные. На
самом деле моделей значительно больше, однако остальные не так широко
6
Высшая школа цифровой культуры Университет ИТМО
распространены. Кроме того, последнее время многие системы позволяют
использовать несколько моделей. В этом случае их называют мультимодаль-
ными или гибридными.
Для NoSQL систем характерно наличие возможностей для масштабиро-
вания как вертикального, так и горизонтального.
Вертикальное масштабирование (scaling up) означает увеличение
количества доступных ресурсов за счет увеличения мощности применяемых
серверов.
Горизонтальное масштабированиеозначает разбиение системы на
более мелкие структурные компоненты и разнесение их по отдельным серве-
рам и увеличение количества серверов, параллельно выполняющих одну и ту
же операцию.
Горизонтальная масштабируемость в этом контексте означает возмож-
ность не изменять мощности используемых серверов (что характерно для
вертикального масштабирования), а добавлять к системе новые узлы для
увеличения общей производительности. Этот способ масштабирования мо-
жет потребовать внесения изменений в программное обеспечение на стороне
приложения или СУБД. Большинство NoSQL систем изначально проектиру-
7
Высшая школа цифровой культуры Университет ИТМО
ется с расчетом на горизонтальное масштабирование и решает эти проблемы
на стороне СУБД.
В базахданных NoSQL хранениеданных происходитзначительно проще,
чем в традиционных. Сторонники неструктурированных баз данных подчер-
кивают их свободу и гибкость. Хранилища типа "ключ-значение"позволяют
сохранять и выбирать данные по ключу и не задумываться о содержании дан-
ных. Документные хранилища данных, по существу, делают то же самое, но
при этом позволяют манипулировать с фрагментами слабоструктурирован-
ных данных. Графовые хранилища свободно добавляют новые узлы и ребра в
граф, а также новые свойства к узлам и ребрам. Колоночные хранилища так-
же позволяют легко добавлять новые поля к отдельным записям и удалять
старые, не вынуждая при этом проводить глобальную перестройку всей базы.
Помимо обеспечения удобных изменений, неструктурированные базы данных
облегчают обработку неоднородных данных, т.е. данных, в которых все запи-
си имеют разные наборы полей. В базах с традиционной организаций схема
вынуждает хранить все записи в одинаковом формате. Это может оказаться
неудобным, если в разных строках хранятся разные данные. В этом случае
множество неиспользуемых полей оказываются заполненными неопределен-
ными или заданными по умолчанию значениями. Неструктурированные базы
данных позволяют избежать этого, позволяя каждой записи хранить все, что
требуется, – не больше и ни меньше.
В отличие от реляционной модели, которая хранит сущности в нормали-
зованном виде в различных таблицах, большинство NoSQL хранилищ опери-
руют с этими сущностями как с целостными объектами и хранят их в денор-
мализованном виде.
В примере на слайде продемонстрировано реляционное представление
для базы “мультфильмы-режиссеры-композиторы” и соответствующий ему
агрегат в формате JSON. Обратите внимание, что в отличие от реляционной
модели, где данные “размазаны” по пяти таблицам в агрегате NoSQL дан-
ные о мультфильме объединяются со списком режиссеров и композиторов
8
Высшая школа цифровой культуры Университет ИТМО
в один логический объект. Такая денормализация нужна, чтобы не запра-
шивать имена режиссеров и композиторов при извлечении фильма. Основ-
ной смысл такого объединения – минимизация количества соединений между
различными объектами. Этим демонстрируется главное правило проектиро-
вания структуры данных во многих NoSQL базах – они должны подчиняться
требованиям приложения и быть максимально оптимизированы под наиболее
частые запросы.
Еслирежиссерырегулярноизвлекаютсявместесфильмом–имеетсмысл
их включать в общий объект, если же большинство запросов работает только
с режиссерами – значит, лучше их вынести в отдельную сущность. Очевид-
но, что работа с большими денормализованными объектами чревата много-
численными проблемами при выполнении произвольных запросов к данным,
когда запросы не укладываются в структуру агрегатов. В этом случае при
получении требуемой информации нам придется извлекать массу информа-
ции, которая абсолютно не нужна. К сожалению, это компромисс, на который
приходится идти в распределенной системе: мы не можем проводить норма-
лизацию данных как в обычной односерверной системе, так как это создаст
необходимость объединения данных с разных узлов и может привести к зна-
чительному замедлению работы базы.
Долгое время согласованность (Consistency) данных была “священной”
для разработчиков баз данных. Все реляционные базы обеспечивали тот или
иной уровень изоляции транзакций. С приходом огромных массивов инфор-
мации и распределенных систем стало ясно, что обеспечить для них изоли-
рованность транзакций с одной стороны и получить высокую доступность и
быстрое время отклика с другой – невозможно.
Более того, даже обновление одной записи не гарантирует, что любой
другой пользователь моментально увидит изменения в системе, ведь изме-
нение в распределенной системе может произойти, например, в мастер-узле,
9
Высшая школа цифровой культуры Университет ИТМО
а реплика асинхронно скопируется на узлы, с которыми работают другие
пользователи. В таком случае пользователи увидят результат через какой-то,
пусть минимальный, но все же промежуток времени. Это свойство принято
называть “согласованностью в конечном счете” (Eventual Consistency) и
это то, на что идут сейчас все крупнейшие интернет-компании мира, включая
Facebook и Amazon. Последние, например, декларируют, что максимальный
интервал, в течение которого пользователь может видеть несогласованные
данные, составляет не более секунды. Пример такой ситуации показан на
слайде.
Два пользователя с разницей в несколько миллисекунд забронировали
один и тот же номер. Второй пользователь умудрился попасть в момент зака-
за именно в тот временной интервал, когда данные на несколько миллисекунд
оказались несогласованными. Такое событие крайне маловероятно, но оно все
же случилось! Что делать в этом случае? Разумеется, бизнес, который осо-
знанно выбрал приложение и хранилище, обеспечивающие быстрый отклик
системы для конечного пользователя и свойство “согласованности в конечном
счете” (Eventual Consistency) должен предусматривать какие-то сценарии от-
ката операции как с точки зрения приложения, так и самого бизнеса. В при-
веденном примере – в гостиницах принято держать “пул” свободных номеров
на непредвиденный случай, а в приложениях выполнять откат несогласован-
ного заказа. На самом деле слабая поддержка согласованности не означают,
что ее нет вообще. NoSQL системы поддерживают ее в той мере, в какой она
необходима для целей конкретных приложений.
Многие NoSQL системы поддерживают, так называемые, BASE-
свойства (Basic Availability, Soft State, Eventual Consistency). В этом назва-
нии Basic Availability означает, что данные доступны всегда, когда к ним про-
исходит обращение, даже если часть из них в настоящий момент недоступна;
Soft State означает, что данные могут находиться в рассогласованном состоя-
нии какой-то период времени, а Eventual Consistency означает, что в конечном
10
Высшая школа цифровой культуры Университет ИТМО
счете, после некоторого периода времени данные в хранилище окажутся в со-
гласованном состоянии. Тем не менее, некоторые NoSQL хранилища данных,
например Couch DB обеспечивают полную поддержку согласованности, как
это принято в традиционных СУБД.
В следующем фрагменте лекции мы обсудим технологии, используемые
для NoSQL систем.
1.3 Технологии
Лавинообразный рост количества данных обострил проблему масштаби-
руемости данных – вычислительные мощности компьютеров не могут расти
бесконечно, да и цена нескольких простых серверов меньше, чем цена одного
высокопроизводительного сервера.
Как мы уже упоминали ранее, в такой ситуации хорошим выходом ста-
новится горизонтальное масштабирование, в котором несколько независимых
серверов соединяются вместе в кластер и каждый из них обрабатывает толь-
ко часть запросов. Такая архитектура делает возможным быстрое увеличе-
ние мощности кластера путем добавления нового сервера. NoSQL хранилища
изначально проектируются как распределенные системы с таким расчетом,
что все процедуры репликации, распределения данных и обеспечения отка-
зоустойчивости выполняются самой NoSQL системой.
11
Высшая школа цифровой культуры Университет ИТМО
Ключевые моменты NoSQL систем по организации распределенной рабо-
ты реализуются с помощью технологийрепликации, фрагментации (или
шардинга) и технологииMapReduce. Рассмотрим эти технологии подроб-
нее.
Репликация – это копирование данных при их обновлении на другие
сервера. Именно этот механизм позволяет добиться большей отказоустойчи-
вости и масштабируемости системы. Принято выделятьдва вида реплика-
ции: свыделенным мастер-сервером (master-slave)и одноранговую
(peer-to-peer).
Первый тип подразумевает наличие одного мастер-сервера и нескольких
дочерних серверов. Запись может производиться только на мастер-сервер, а
он в свою очередь передаёт изменения на дочерние машины. Этот тип репли-
кации даёт хорошую масштабируемость на чтение (чтение может происхо-
дить с любого узла сети), но не позволяет масштабировать операции записи
- запись идёт только на один мастер- сервер. Такой вариант организации ре-
пликации предполагает сложности в случае неисправности мастер-сервера,
так как в таком случае должен происходить автоматический или ручной вы-
бор нового мастер-сервера из оставшихся.
12
Высшая школа цифровой культуры Университет ИТМО
Второй тип – одноранговая сеть (peer-to-peer) – предполагает, что все
узлы равны в возможности обслуживать запросы на чтение и запись. Ин-
формация об обновлении данных передаётся от сервера к серверу по кругу.
Следующая технология – фрагментация.Фрагментация (sharding) –
это разделение массива информации по разным узлам сети - когда каждый
узел отвечает только за определенный набор данных и обрабатывает запросы
на чтение и запись, относящиеся только к этому набору данных. Эта техно-
логия и раньше использовалась при работе с реляционными базами данных,
но в достаточно сыром виде. Создавались независимые базы данных, по ко-
торым приложение распределяло запросы пользователей. Концепция NoSQL
предполагает, что ответственность за этот механизм возлагается на саму базу
данных, и фрагментация производится автоматически.
Последняя из упомянутых технологий – технологияMapReduce. Для
подавляющего большинства NoSQL систем характерно использование техно-
логии MapReduce. MapReduce – это технология эффективного распаралле-
ливания задач по кластеру. Эта технология сегодня имеет множество разно-
13
Высшая школа цифровой культуры Университет ИТМО
образных реализаций. Но есть классическая идея, которую мы попытаемся
изложить. Рассмотрим простой пример.
Представьте, что вам нужно узнать частоту использования тех или иных
слов в произведениях Шекспира. Вы, конечно, можете начать просматривать
все его произведения и выписывать пары (слово, частота слова в предложе-
нии) для каждого встретившегося слова. Когда Вы дойдете до конца послед-
него произведения – Вы сможете проагрегировать результаты и определить,
какое слово сколько раз встретилось.
Но, очевидно, что на эту работу Вам придется потратить много време-
ни. Вы можете попробовать попросить своих друзей помочь Вам и раздать
каждому из них по произведению. Однако друзей должно быть достаточно
много, так как Шекспир написал 38 пьес, 154 сонета, а также еще несколько
других поэтических произведений.
Кроме того, даже если Вам удастся найти такое количество друзей, то
желательно, чтобы они предоставили результат анализа произведений не в
виде длинных списков слов, а в агрегированном виде, где про каждое сло-
во уже будет известно, сколько раз оно встретилось в произведении. А уже
Вы, собрав все предварительные результаты агрегирования, сможете прове-
сти финальную агрегацию для каждого слова.
Собственно, в этом простом примере и изложена вся технология
MapReduce. Как этот пример может быть трактован с точки зрения совре-
менных технологий? Когда Вы собрали друзей – Вы сформировали кластер
для проведения распределенных вычислений.
Когда Вы разделили произведения Шекспира среди своих друзей –
Вы поступили как мастер-узел кластера, который распределяет данные
для вычислений на кластере. Когда Ваши друзья выписывали пары <сло-
во,частота> (т.е. формировали пары ключ- значение) — они выполняли фазу
Map (отображение) из технологии MapReduce.
Когда Ваши друзья, а затем Вы агрегировали результаты по каждому
14
Высшая школа цифровой культуры Университет ИТМО
слову - вы выполняли фазу Reduce (свертка) из технологии MapReduce. Ри-
сунок на слайде демонстрирует основные этапы технологии MapReduce на
примере анализа сонета Шекспира.
1.4 Примеры NoSQL систем
Модели данных и методы работы с данными систем класса NoSQL
чрезвычайно разнообразны. Количество таких систем уже трудно сосчитать.
По ссылкеhttps://hostingdata.co.uk/nosql-database/ доступен один из
наиболее полных перечней NoSQL систем.
В этом списке числится более 200 систем. Почему их так много? Причи-
на состоит в том, что характерной особенностью этих систем является ори-
ентация на узкий класс задач. А прикладных задач действительно много и
становится все больше. Так какие из систем являются наиболее востребован-
ными? Как понять, что следует изучать? Каким-нибудь случайным образом
выбрать их из списка?
Нет, мы не будем полагаться на случай. Вспомним, что системы NoSQL
разбиваются на разного рода группы, среди которых особо выделяют следу-
ющие 4 категории: колоночные, ключ-значение, документные и графовые.
Попытаемся найти наиболее рейтинговых представителей этих катего-
рий. Обратимся к сервису DB-Engines Ranking (https://db-engines.com/
en/ranking), который по определенным алгоритмам (а именно: упоминание
в разнообразных публикациях и т.п.) формирует рейтинги наиболее попу-
лярных систем разных категорий. Выберем в интерфейсе категорию ключ-
значение (Key-value stores). Наиболее популярными представителями систем
категории класс-значение согласно рейтингу DB-Engines Ranking на момент
записи этой лекции являются: Redis, Amazon DynamoDB (мультимодельная
15
Высшая школа цифровой культуры Университет ИТМО
система), Memcached. Утверждается, что эти системы позволяют добиваться
высокой производительности, могут легко масштабироваться, но эффектив-
ный поиск в таких моделях возможен только по уникальному ключу. При
этом сам запрашиваемый объект может быть как последовательностью бай-
тов, так и более сложной структурой. Авторы систем декларируют высокую
производительность, однако надо признать, что для объективного сравнения
производительности систем категории ключ-значение и традиционных СУБД
необходимо произвести сравнение на основе сопоставимых операций. Опера-
ции, выполняемые в традиционных СУБД с помощью одного высокоуровнего
запроса, в системах типа ключ-значение могут потребовать десяток, а то и
сотню низкоуровневых операций. Сравнение на основе мелких операций ти-
па ключ-значение представляется не совсем справедливым, так как сильной
стороной высокоуровневых запросов является именно массированная, а не
единичная обработка данных. К серьезным недостаткам этих систем можно
отнести полное отсутствие отношений между сущностями. Это означает, что
система управления хранилищем не может проконтролировать целостность
отношений и соответствующая функциональность целиком ложится на при-
ложения. Тем не менее, для некоторого класса задач этого вполне достаточно
и такие хранилища используются весьма эффективно (например, для хране-
ния изображений, видеороликов, файлов и т.п).
Выберем в качестве фильтра – документные хранилища и увидим
следующую картину. Среди систем, ориентированных на обработку доку-
ментов, согласно рейтингу DB-Engines Ranking заслуживают упоминания:
MongoDB, Couchbase и уже упомянутая ранее мультимодельная система
Amazon DynamoDB. В рамках документарной модели эти системы хранят
объекты (документы) в формате JSON (Java Script Object Notation) или
BSON (Binary JSON). Форматы JSON и BSON допускают атрибуты простых
типов, массивы, а также вложенные объекты. Эти системы поддерживают
индексы на полях документов и позволяют строить сложные запросы. Пол-
16
Высшая школа цифровой культуры Университет ИТМО
ноценных транзакций в них также нет. Тем не менее, операции обновления
на уровне одного документа обычно являются атомарными. Такие хранили-
ща данных эффективно применяются в системах управления содержимым,
издательском деле, документальном поиске и т. п.
Выберем в качестве фильтра – графовые системы. Это системы, ори-
ентированные на обработку графов и предназначеные для хранения узлов
графов и связей между ними. Как правило, такого рода системы позволяют
задавать для узлов и связей еще и набор произвольных атрибутов и выби-
рать узлы и связи по этим атрибутам. Кроме того, системы поддержива-
ют алгоритмы обхода графов и построения маршрутов. Согласно рейтингу
DB-Engines Ranking список граф-ориентированных хранилищ возглавляют:
Neo4j, Microsoft Azure Cosmos DB, OrientDB и ArangoDB. При этом послед-
ние четыре хранилища также позиционируются как мультимодельные. Граф-
ориентированные хранилища эффективно используются для задач, связан-
ных с анализом социальных сетей, выбором маршрутов и т.п.
Особое место среди NoSQL – систем занимают колоночные хранилища
17
Высшая школа цифровой культуры Университет ИТМО
данных. Их также принято относить к NoSQL. Группу колоночных хранилищ
согласно рейтингу DB-Engines Ranking на момент написания лекции возглав-
ляют: Cassandra, HBase, Microsoft Azure Cosmos DB. Основная особенность
хранилищ этого типа заключается в том, что данные представляются в виде
таблиц, а хранение и фрагментация этих данных возможны не по строкам,
как это принято в традиционных СУБД, а по столбцам. Кроме того, для мно-
гих систем этого класса характерно наличие SQL-подобных языков высокого
уровня.
На протяжении десятилетия NoSQL движение набирает популярность.
Появляются новые системы, которые позиционируют себя как NoSQL. Какое-
то время еще можно было понять принцип работы той или иной системы на
основе того, к какой категории она относится (графовая, ключ-значение, до-
кументная или колоночная). Однако, даже это деление на категории стано-
вится условным, так как многие из хранилищ допускают несколько способов
хранения данных и, как следствие, становятся мультимодельными система-
ми. И, тем не менее, попробуем разобраться в принципах работы NoSQL си-
стем на конкретных примерах. В качестве примеров в следующих разделах
рассмотрим наиболее ярких представителей каждой категории.
18
Высшая школа цифровой культуры Университет ИТМО
2 Redis
В этой лекции мы познакомимся с основами Redis. Почему именно Redis?
Да просто потому, что именно его считают наиболее ярким представителем
группы “ключ-значение”. Часто Redis описывают как хранилище данныхin
memory (то есть в оперативной памяти). Да, действительно, Redis, держит
вседанныевоперативнойпамяти,однакопериодическисохраняетэтиданные
на диске. Кроме того, Redis не просто хранит данные типа ключ-значение, а
содержит данные гораздо более сложных структур.
Данные в Redis могут быть представлены в виде пяти разных структур,
и только одна из них, собственно, и есть в чистом виде структура типа ключ-
значение. Понимание этих пяти структур, как они работают, какие методы
предоставляют для взаимодействия с пользователем, и что можно сделать с
их помощью, как раз и являются ключом к пониманию Redis. Но сначала
разберемся с тем, какие именно структуры данных возможны в Redis.
Если обратиться к реляционным базам, то можно сказать, что базы дан-
ных предоставляют один универсальный тип структур данных – таблицы.
Таблицы одновременно сложные и в то же время гибкие. Их универсаль-
ность заключается в том, что любые структуры данных можно смоделиро-
вать с помощью таблиц. Тем не менее, они не идеальны. А именно: их не
19
Высшая школа цифровой культуры Университет ИТМО
всегда достаточно просто приспособить для представления данных, и они не
всегда достаточно быстро позволяют организовать доступ к требуемым дан-
ным. Именно поэтому и появилась идея вместо универсальной структуры ис-
пользоватьспециализированныеструктуры,ориентированныенаконкретные
прикладные задачи. Конечно, в этом случае, наверное, найдутся данные, ко-
торые мы не сможем представить в виде узкоспециализированных структур,
однако для каких-то данных, мы выиграем в простоте и скорости доступа.
Использование специфичных структур данных для специфичных задач? Да,
именно в этом и состоит подход Redis. Если в прикладной задаче вам необ-
ходимы не таблицы, а скаляры, списки, хеши или множества, то почему бы с
самого начала не пытаться представлять их не в виде таблиц, а хранить как
скаляры, списки, хеши и множества?
Как и где можно познакомиться со структурами данных и приемами
работы в Redis чтобы получить минимальные практические навыки? Мож-
но скачать дистрибутив Redis с официального сайта https://redis.io/
download, установить его на своем компьютере и получить базу Redis в свое
полное распоряжение. Redis использует знакомую всем концепцию базы дан-
ных. База – это набор данных. Типичное предназначение базы данных Redis –
это группировка всей информации определенного приложения в одном месте
и изоляция ее от других приложений.
В Redis база данных идентифицируется целым числом, которое по умол-
чанию равняется 0 (а соответствующая база называется базой по умолча-
нию). Если необходимо переключиться на другую базу данных, то можно это
сделать командойSELECT. Например, для переключения на базу с идентифи-
катором 1 достаточно в командной строке ввести команду:SELECT 1
Redisдолженответитьсообщением OK,автерминалевыдолжныувидеть
что-то типа того, что видите сейчас на слайде. Если требуется переключиться
обратно на базу по умолчанию, просто введите в командной строке:SELECT
0.
20
Высшая школа цифровой культуры Университет ИТМО
Одним из основополагающих понятий Redis является понятие клю-
ча. Несмотря на то, что Redis больше, чем просто хранилище типа ключ-
значение, в его основе каждая из пяти используемых структур обязательно
имеет ключ и значение. Поэтому очень важно разобраться в том, что такое
ключи и что такое значения, перед тем как двигаться дальше.
Итак, что собой представляет ключ в паре “ключ-значение”? Прежде все-
го, он должен быть уникальным в базе. Это идентификатор, который позво-
ляет получить доступ к ассоциированному с ним значению. Теоретически он
может быть любым. Однако в практических реализациях всегда есть огра-
ничения, связанные, как минимум, с его размером. В качестве ключа можно
использовать любую последовательность символов – от короткой строки тек-
ста до содержимого файла изображения. Даже пустая строка является допу-
стимым ключом. Однако из соображений производительности следует избе-
гать слишком длинного ключа. В хранилищах типа "ключ-значение"большое
внимание уделяется выбору структуры самого ключа. Ключи можно гене-
рировать с помощью специальных алгоритмов и задавать явно. В качестве
ключа может выступать идентификатор пользователя, электронный адрес,
номер телефона и т.п. Ключ можно формировать из даты, времени и иден-
тификаторов приложений, работающих с базой. Еще одна идея – форми-
ровать ключи в виде следующей структуры: <тип объекта:идентификатор
21
Высшая школа цифровой культуры Университет ИТМО
объекта:атрибут>. Таким образом можно сохранять в хранилищах “ключ-
значение” всю информацию об объектах и получать доступ к значениям атри-
бутов объектов. С помощью специальных методов можно задавать интервал
времени, по истечении которого ключ станет недействительным. Последнее
свойство особенно удобно для работы с сессионными объектами и корзинами
покупателей. На слайде Вы можете видеть примеры ключей. Они достаточно
разнообразны. Это и просто последовательность символов, и имя агента 007,
и электронный адрес, и номер телефона и даже простые дата и время. Любая
из этих структур может быть ключом.
Значением в хранилище “ключ-значение” может быть что угодно. На-
пример, длинный или короткий текст, число, программный код, изображение
и т. п. Значение также может быть списком, множеством или даже другой
парой ключ-значение, инкапсулированной в объект.
Некоторые хранилища позволяют указывать тип данных для значения.
22
Высшая школа цифровой культуры Университет ИТМО
Например, можно указать, что значение должно быть целым числом. Дру-
гие хранилища не предоставляют эту функциональность и, следовательно,
значение может быть любого типа. Однако не все команды применимы к
значениям любого типа. Например, команда, которая увеличивает значение
на 1, подразумевает, что ее операндом может быть только численное значе-
ние. Рассмотрим некоторые примеры ассоциированных ключей и значений.
Очень хорошо известный нам пример – справочник телефонов (или как сей-
час говорят - контактов). Ключ-имя, а значение – номер телефона.
Еще один возможный пример – коллекция мультфильмов. Здесь ключ
организован по принципу <тип объекта:идентификатор:атрибут> и в приве-
денном примере легко разобраться где хранится название мультфильма, где
год выпуска, а где – количество просмотров.
Для хранилищ типа “ключ-значение” характерно использование языков
запросов низкого уровня (не декларативных). Запросы в хранилищах типа
"ключ-значение"могут выполнять команды по ключу и ничего более. Резуль-
татом запроса является все значение. Часть значения вытащить с помощью
23
Высшая школа цифровой культуры Университет ИТМО
запроса невозможно. Даже, если значением является слабоструктурирован-
ный документ JSON-формата, вытащить отдельные атрибуты документа на
уровне запроса не удастся. Анализ выбранного документа может быть про-
изведен только на уровне приложения.
И, тем не менее, этих, казалось бы, весьма ограниченных, возможно-
стей для многих приложений вполне хватает. На слайде приведены несколь-
ко запросов в СУБД Redis. Составным ключам мультфильм-идентификатор-
атрибут сопоставляются имена, годы выпуска и количество просмотров, со-
ответствующих мультфильмам. Сопоставление производится с помощью ко-
манды SET.
Есть и обратная операция. Ее действие также продемонстрировано на
слайде. Это команда GET. Она позволяет достать из хранилища значение,
соответствующее ключу. Можно достать имя мультфильма и любые другие
значения.
24
Высшая школа цифровой культуры Университет ИТМО
Кроме того, в списке основных команд есть командаKEYS. Она позволяет
выбирать значения ключей в соответствии с заданным шаблоном. На слайде
вы можете видеть, как выбираются все ключи с префиксомCARTOON.
3 MongoDB
3.1 Основы
В этой лекции мы познакомим слушателей с основами документного хра-
нилищаданных–системойMongoDB.ПочемуименноMongoDB?Потому,что
именно MongoDB (согласно упомянутому ранее рейтингу) принято считать
наиболее ярким представителем группы документных хранилищ.
25
Высшая школа цифровой культуры Университет ИТМО
MongoDB представляет собой систему для управления документно-
ориентированными базами данных, которая реализует новый подход к по-
строению баз данных, где нет таблиц, схем, запросов SQL, внешних клю-
чей и многих других объектов, присущих традиционным реляционным базам
данных. MongoDB в некоторых случаях работает быстрее, обладает лучшей
масштабируемостью, и, наконец, ее легче использовать. При этом важно по-
нимать, что задачи бывают разные и методы их решения бывают разные.
В какой-то ситуации MongoDB действительно улучшит производительность
приложения, например, если надо хранить сложные по структуре данные. В
другой же ситуации лучше будет использовать традиционные реляционные
базы данных. Вся система MongoDB может представлять не только одну базу
данных, находящуюся на одном физическом сервере. Особенность архитек-
туры MongoDB позволяет расположить несколько баз данных на одном или
нескольких физических серверах, и эти базы данных смогут легко обмени-
ваться данными и даже сохранять целостность.
Базу данных MongoDB можно представить в виде иерархической струк-
туры как это указано на рисунке. Если в реляционных базах данные хранят-
ся в таблицах, то в MongoDB база данных состоит из коллекций. Каждая
коллекция имеет свое уникальное имя – произвольный идентификатор, со-
стоящий не более чем 128 различных алфавитно-цифровых символов и знака
26
Высшая школа цифровой культуры Университет ИТМО
подчеркивания. Коллекции в свою очередь состоят из документов. Именно
документы хранят полезную информацию. В некотором смысле документы
подобны строкам в реляционных базах, где строки хранят информацию об
отдельных объектах.
В отличие от строк документы могут хранить сложную по структуре ин-
формацию, которую принято называть слабоструктурированной. Документ
можно представить как хранилище ключей и значений. Ключ представляет
собой простую метку, с которой ассоциирован определенный фрагмент дан-
ных из документа. Для каждого документа имеется свой уникальный ключ,
который называется_id. И если явным образом не указать его значение, то
MongoDB сгенерирует для него значение автоматически.
Как уже упоминалось ранее, одним из популярных стандартов обмена
даннымиииххраненияявляетсяформат JSON (JavaScriptObjectNotation).
JSON эффективно описывает сложные по структуре данные. Способ хране-
ния данных в MongoDB в этом плане похож на JSON, хотя формально JSON
не используется. Для хранения в MongoDB применяется формат, который
27
Высшая школа цифровой культуры Университет ИТМО
называется BSON (БиСон) или сокращение от binary JSON. Формат BSON
позволяет работать с данными быстрее: быстрее выполняется поиск и обра-
ботка. Хотя надо отметить, что BSON в отличие от хранения данных в фор-
мате JSON имеет небольшой недостаток: в целом данные в JSON-формате
занимают меньше места, чем в формате BSON, но, с другой стороны, дан-
ный недостаток окупается скоростью. На рисунке Вы можете видеть пример
документа в формате JSON.
Всему документу соответствует уникальный идентификатор, т.е. ключ
_id со значением, равным1. Отдельные поля в документе также представ-
лены в виде набора пар ключ-значение. Например, ключу"CartoonName" со-
ответствует одно значение"The Lion King", а ключу "FilmDirectorName"
массив значений:["Roger Allers "Rob Minkoff"].
Следует обратить внимание на то, что ключи в MongoDB являются
регистро-зависимыми. Два ключа на приведенном рисунке различаются.
Ключи идентифицируют значения. Значения же могут различаться по
типу данных. В приведенном ранее примере "CartoonName"соответствует
строковому значению,"Year" – целочисленному,"FilmDirectorName" – мас-
сиву строковых значений. На рисунке приведены наиболее используемые ти-
пы значений, среди которых вы можете видеть: строки, целые значения, ло-
28
Высшая школа цифровой культуры Университет ИТМО
гические, массивы и даже регулярные выражения.
Следует обратить внимание, что значения в документах обладают стро-
гой типизацией, например, следующие два документа не будут идентичными.
Если в первом случае для ключа"Duration" определена в качестве значения
строка, то во втором случае значением является число. И именно поэтому
значения этих ключей считаются различными.
Система MongoDB ориентирована на хранение документов. Однако
эти документы иногда оказываются документами очень большого размера.
MongoDB позволяет сохранять данные большого размера, однако при этом
размер одного документа ограничивается 16 Мб. Но в MongoDB имеется спе-
циальное решение – технология GridFS, которая позволяет хранить данные
по размеру больше, чем 16 Мб. Суть технологии GridFS заключается в ис-
пользовании двух специальных коллекций. В первой коллекции, которая на-
зывается files, хранятся имена файлов, а также их метаданные, например
29
Высшая школа цифровой культуры Университет ИТМО
размер. А в другой коллекции, которая называется chunks, в виде небольших
сегментов хранятся данные файлов, обычно сегментами по 256 Кб.
30
Высшая школа цифровой культуры Университет ИТМО
3.2 Начало работы с MongoDB и управление ба-
зами
Для установки MongoDB можно загрузить один распространяе-
мых пакетов с официального сайта MongoDB: https://www.mongodb.com/
download-center#community. Официальный сайт предоставляет пакеты дис-
трибутивов для различных платформ: Windows, Linux, MacOS, Solaris. Для
каждой платформы доступно несколько дистрибутивов разных версий. Кро-
ме того, предлагаются два вида серверов – Community и Enterprise. Для учеб-
ных целей вполне достаточно версии Community. Но следует иметь в виду,
что Enterprise-версия обладает несколько большими возможностями.
Для выполнения заданий настоящего курса можно воспользоваться
версией MongoDB, установленной на одном из серверов ИТМО: https://
online.ifmo.ru/mongo/.
При использовании этого сервера качестве user-name нужно указать
31
Высшая школа цифровой культуры Университет ИТМО
itmo, а в качестве пароля –online. В качестве имени базы для всех при-
меров данной лекции будет использоваться базаglobalStudent.
На рисунке вы можете видеть пример аутентификации пользователя на
сервере ИТМО. Обратите внимание, что пароль при вводе не отображается.
Система MongoDb может работать одновременно с несколькими базами.
Однако существует понятие текущей базы, а в связи с этим есть набор команд
MongoDb, который позволяет уточнить список доступных баз, установить те-
кущую базу, просмотреть статистику по базе и уточнить содержимое текущей
базы (т.е. список коллекций). На рисунке приведен список команд, предна-
значенный для управления базами MongoDB. Это и команды для демонстра-
ции доступных баз, и команды для установки текущей базы, и демонстрация
статистики по текущей базе, и отображение списка коллекций базы, и до-
бавление новых документов в коллекцию. Зачем нужна текущая база? При
работе с MongoDB, надо прежде всего установить требуемую базу данных в
качестве текущей, чтобы затем ее использовать. Для этого надо либо с самого
начала присоединиться к нужной базе, либо использовать для подключения
команду use. При этом не важно, существует ли такая база данных или нет.
Если ее нет, то MongoDB автоматически создаст ее при добавлении в нее
данных.
Как увидеть список доступных баз данных? Для это существует команда
32
Высшая школа цифровой культуры Университет ИТМО
show dbs
Приведенный рисунок демонстрирует пример просмотра списка доступных
баз.
Теперь можно подключиться к нужной базе (например,globalStudent)
с помощью командыuse. Приведенный рисунок демонстрирует такое пере-
ключение на базуglobalStudent и соответствующее сообщение системы.
Если в командеuse используется имя, которого нет в списке баз, то будет
создана новая база. В качестве имени можно задать любое имя, однако есть
некоторые ограничения. Например, в имени не должно быть некоторых спе-
циальных символов. Они перечислены на рисунке. Кроме того, имена баз по
длине ограничены 64 байтами. А еще есть зарезервированные имена (local,
admin и config), которые также нельзя использовать.
33
Высшая школа цифровой культуры Университет ИТМО
Команды use и show dbs тесно связаны между собой. Взгляните на при-
мер на рисунке. Команда use пытается переключиться на новую базу, не
находит ее и вынуждена создать новую базу с именемnewDB. После этого
используется командаshow dbs. Очевидно, что мы ожидаем увидеть новую
базу в списке баз, которые отображаются в результате выполнения команды.
Однако это не так. Новая база появится в списке баз только после того, когда
в ней появятся реальные данные. Для того, чтобы узнать какая база исполь-
зуется в текущий момент времени, можно воспользоваться командойdb. На
рисунке приведен пример использования этой команды. Можно увидеть, что
текущая база –newDB.
34
Высшая школа цифровой культуры Университет ИТМО
Следующий рисунок демонстрирует как с помощью команды
db.stats()
можно узнать разнообразную статистику о текущей базе (в частности ее раз-
мер). Для этого сначала с помощью команды use происходит переключение
базы, а затем собирается статистика по базе. В частности, можно увидеть,
что имя базы –globalStudent, в базе3 коллекции и8588 объектов и т.п.
Для того, чтобы увидеть имена коллекций можно воспользоваться ко-
мандой
show collections
Приведенный рисунок демонстрирует, как можно уточнить из каких кол-
лекций состоит база. Команда была применена к демонстрационной базе
globalStudent. Мы видим 3 коллекции: STOPS, UNDREGROUND и student.
Следует обратить внимание, что имена коллекций являются регистро-
зависимыми, а, следовательно, именаstudent и STUDENT будут представлять
разные коллекции.
Как создать новую коллекцию в текущей базе? Казалось бы, что снача-
ла надо бы создать коллекцию, а потом добавлять в нее новые документы.
35
Высшая школа цифровой культуры Университет ИТМО
Однако в MongoDB специально создавать коллекции можно, не обязатель-
но. Новая коллекция будет создана автоматически при добавлении первого
документа. Итак, напишем команду, которая добавит новый документ в кол-
лекцию CARTOON в текущей базе.
db.CARTOON.insert(
{
"CartoonName": "The Lion King",
"Year": 1994,
"Country": "USA",
"Duration": 88,
"FilmDirector": ["Roger Allers", "Rob Minkoff"]
})
В команде надо указать имя коллекции и, собственно, сам добавляемый
документ. В нашем примере в качестве документа используется документ в
формате JSON, представляющий информацию о мультфильме “Король Лев”.
Однако у этой команды есть особенность – она выполнима только в том слу-
чае, когда у пользователя достаточно прав для редактирования базы. Но если
Вы работаете с базойglobalStudent на сервере ИТМО, то у Вас таких прав
явно недостаточно, так как этабаза открыта для студентов только на
чтение.
В следующих фрагментах данной лекции будут рассмотрены команды,
позволяющие выбирать данные из существующих коллекций.
36
Высшая школа цифровой культуры Университет ИТМО
3.3 Выборка данных из коллекций
Выборка данных их коллекций в MongoDB осуществляется при помощи
команды find. Действие этой команды, в конечном счете, во многом анало-
гично обычному запросу select в реляционной базе. Так же, как и в команде
select, ключевые моменты запроса задаются с помощью условия выборки
(т.е. фильтра) и проекции. И, тем не менее, синтаксически они отличаются.
На рисунке приведен синтаксис командыfind.
При использовании команды нужно явным образом указать имя коллек-
ции, из которой осуществляется выборка. Обратите внимание на квадратные
скобки в описании команды. Они указывают, что соответствующая часть кон-
струкции может быть пропущена. Например, можно написать запрос, в ко-
тором не будет ни фильтра для выбираемых записей, ни проекции. В этом
случае в результат запроса попадут все данные присутствующие в коллек-
ции. Именно такой запрос мы сейчас и продемонстрируем на конкретном
примере. Приведем пример простейшего варианта использования команды
find. Например, чтобы извлечь все документы из коллекции student, можно
использовать команду:
37
Высшая школа цифровой культуры Университет ИТМО
db.student.find()
В языке SQL этой команде бы соответствовал запрос:
select * from student
Фильтр и проекция в данном запросе не используется. На следующем
рисунке видим результат выполнения команды в демонстрационной базе
globalStudent.
Для вывода документов в более удобном наглядном представлении мы
можем добавить вызов методаpretty().
И результат будет выведен совсем в ином стиле, который является более
характерным для отображения документов формата JSON.
В приведенном примере мы рассмотрели выборку всех документов, одна-
ко,еслинамнадополучитьневседокументы,атолькоте,которыеудовлетво-
ряют определенному условию, то придется использовать в команде фильтр
для отбора требуемых документов.
38
Высшая школа цифровой культуры Университет ИТМО
Например, выведем все документы (из коллекцииstudent), для которых
будет задан фильтр{age:19}. То есть то, что в реляционных базах выводи-
лось бы запросом
select * from student where age = 19
В MongoDB для этого придется написать следующий запрос:
db.student.find({age:19})
Проекция в запросе, по-прежнему, не используется.
На рисунке вы можете видеть результат выполнения запроса и убедить-
ся, что туда, действительно, попали только 19-летние студенты.
Усложним запрос и выведем только19-летних студентов по имени
Simon. В запросе придется задать более сложный фильтр для данных:
db.student.find({age:19, name: "Simon"})
39
Высшая школа цифровой культуры Университет ИТМО
В реляционной базе этому запросу соответствовал бы запрос вида:
select * from student where age = 19 and name = "Simon"
То есть запятая в фильтре интерпретируется как логическая операцияand.
На рисунке вы можете видеть результат выполнения запроса и убедить-
ся, что туда, действительно, попали только19-летние студенты по имени
Simon.
Документ может иметь множество полей, но не все эти поля могут быть
нужны в результате запроса. В этом случае в операторе выборки необходимо
использовать проекцию, позволяющую указать требуемые в конечной выбор-
ке поля.
40
Высшая школа цифровой культуры Университет ИТМО
Например, запрос
db.student.find({age:19},{name:1})
выводит только имена 19-летних студентов. Единица напротив назва-
ния поля в проекции указывает на то, что соответствующее поле должно
присутствовать в выборке. При этом одно поле, а именно_id по умолчанию
будет выведено даже без указания соответствующей единицы, указывающей
на необходимость его присутствия.
Поэтому, если мы не хотим видеть поле_id в выборке, то надо явным
образом упомянуть его в проекции и сопоставить ему значение0:
db.student.find({age:19},{name:1,_id:0})
В качестве альтернативы для0 и 1 в проекции можно использовать ло-
гические значенияtrue и false:
db.student.find({age:19},{name:1,_id:false})
В некоторых случаях требуется вывести данные из базы в соответствии
с каким-то шаблоном, то есть не по точному значению того или иного поля,
а лишь какой-то его части. Для этого можно использовать, так называемые,
регулярные выражения. Регулярные выражения позволяют задать шаблон,
которому должно соответствовать значение строкового поля. В рамках дан-
ной лекции мы не будем приводить точное описание синтаксиса для задания
регулярных выражений в MongoDB, но приведем несколько наиболее часто
используемых шаблонов.
41
Высшая школа цифровой культуры Университет ИТМО
Вот, к примеру, запрос, который выведет всех студентов с именами, в
которых содержится прописная букваS:
db.student.find({name:/S/})
А вот – результат этого запроса в среде MongoDB:
Приведем в качестве примера еще один запрос
db.student.find({name:/s/i})
который выводит всех студентов, в имени которых встречается букваs в
нижнем или верхнем регистрах:
И еще один запрос
db.student.find({name:/se/i})
42
Высшая школа цифровой культуры Университет ИТМО
который выбирает всех студентов, в имени которых встречается подстрока
se независимо от используемого регистра:
И, наконец, последний запрос в этом фрагменте
db.student.find({surname:/a$/})
позволяющий вывести всех студентов, фамилии которых заканчиваются на
букву a:
3.4 Фильтры, сортировка и агрегирование
В приведенных выше примерах мы использовали при выборке данных
фильтры, в которых значение того или иного поля должно было в точности
совпадать с заданным или соответствовать регулярному выражению. Между
тем фильтры могут быть значительно более разнообразными и использовать
разного рода операции. Например, операции сравнения, логические операции
и т.п. Рассмотрим некоторые, наиболее востребованные операции. Начнем с
операций сравнения.
43
Высшая школа цифровой культуры Университет ИТМО
Все операции представляют собой аббревиатуру соответствующего ан-
глийского названия операции. Например,lt – less than. Посмотрим, как ис-
пользуются операции сравнения в следующем запросе.
Сравним, как в SQL и в MongoDB записываются запросы, выбирающие
всех студентов младше 20 лет. Для соответствующего фильтра понадобится
операция less than$lt. Наверное, форма записи условия выборки в MongoDB
выглядит не так изысканно, как в SQL, но, тем не менее, она достаточно
понятна. На рисунке продемонстрирован результат выполнения команды:
Если нам нужно выполнить запрос, в котором требуется провести про-
верку на точное равенство, можно воспользоваться операцией equal –$eq.
44
Высшая школа цифровой культуры Университет ИТМО
Номожнонаписатьзапросвманере,котораяописываласьвпредыдущем
фрагменте лекции и не использует явного упоминания операции сравнения,
а подразумевает его неявно. На рисунке приведен результат выполнения за-
проса, записанного в первой манере:
Операторысравненияможноиспользоватьивболеесложныхвыражени-
ях, где требуется задать несколько ограничений на одно или несколько полей.
Например, нужно вывести студентов, возраст которых больше 20, но меньше
23 лет. Сравним, как такие запросы записываются в SQL и в MongoDB.
В SQL условия выборкиage > 20 и age < 23 соединены логической опе-
рацией and. В варианте с MongoDB эта операция явным образом не записана,
45
Высшая школа цифровой культуры Университет ИТМО
но запятая, соединяющая два условия, неявно эту операцию подразумевает.
Однако в более сложных условиях логические операции можно и нужно за-
писывать явно. На рисунке приведен результат исполнения команды в среде
MongoDB:
В MongoDB так же, как и в SQL, есть возможность явно использовать
стандартные логические операции (то есть операции, объединяющие логи-
ческие значения) для того, чтобы формировать разнообразные условия вы-
борки. Список доступных логических операций приведен на рисунке. Однако
надо признать, что их использование в MongoDB выглядит менее естествен-
но, чем в SQL.
Сравните, как записываются соответствующие запросы, выбирающие
студентов по имениSimon или Anna, в SQL
select * from student where name = "Simon" or name = "Anna"
и MongoDB
db.student.find({$or:[{name:"Simon"},{name:"Anna"}]})
На рисунке приведен результат выполнения такой команды:
46
Высшая школа цифровой культуры Университет ИТМО
Далее приведем в качестве примера два запроса, выбирающих студентов
по имениSimon старше 20 лет. В SQL:
select * from student where name = "Simon" and age > 20
В MongoDB – стандартный операторfind, но с достаточно сложным филь-
тром:
db.student.find({$and:[{name:"Simon"}, {age:{$gt:20}}]})
Как видно из приведенных примеров – запрос в SQL формулируется значи-
тельно проще, чем в MongoDb. На рисунке приведен результат исполнения
команды в среде MongoDB:
MongoDB не только позволяет задавать фильтр и проекцию при выбор-
ке данных, но и указывать дополнительные опции, позволяющие сортировать
и факторизовать результат выборки. Рассмотрим эти возможности подроб-
нее. MongoDB предоставляет возможность отсортировать выборку с помо-
щью функции sort. Передавая в эту функцию в качестве параметра ключ
47
Высшая школа цифровой культуры Университет ИТМО
для сортировки и значение1 или -1, можем указать, в каком порядке следу-
ет производить сортировку по требуемому ключу: по возрастанию (1) или по
убыванию (-1).
Сравним, как записывается в SQL и MongoDB сортировка списка сту-
дентов по возрастанию имени. В SQL для указания сортировки используется
конструкцияorder by (по умолчанию по возрастанию), а в MongoDB – функ-
ция sort с параметрами:name и 1. На следующем рисунке приведен пример
записи сортировка того же списка по убыванию поляname. В SQL для ука-
зания сортировки используется конструкция order by с опцией desc, а в
MongoDB – функцияsort с параметрами:name и -1.
48
Высшая школа цифровой культуры Университет ИТМО
На рисунке приведен результат исполнения последнего запроса:
Иногда нам не нужны все результаты запроса, а достаточно получить
лишь первые несколько документов. Для этого может использоваться функ-
цияlimit. Ее параметр задает требуемое количество документов для вывода.
Например, вывести3 документа из коллекцииstudent можно так, как пока-
зано на рисунке. Но особый смысл в использовании этой функции возникает
тогда, когда мы уже имеем дело с отсортированным списком.
Например, нужно вывести первых десять студентов из отсортированного
по фамилии в лексикографическом порядке списка студентов. Такой запрос
может быть записан так:
db.student.find().sort({surname:1}).limit(10)
На следующем рисунке представлен результат исполнения такого запроса в
среде MongoDB:
49
Высшая школа цифровой культуры Университет ИТМО
Еще одну любопытную возможность предоставляет функцияskip. Она
позволяет пропустить в результате запроса заданное количество документов.
Типичный сценарий ее использования такой: отсортировать список, пропу-
стить в отсортированном списке требуемое количество документов, выбрать
заданное количество документов.
Следующий рисунок демонстрирует результат запроса
db.student.find().sort({surname:1}).skip(10).limit(5)
в котором сортируется список студентов по фамилии, затем пропускаются
первые 10 документов и выводятся следующие 5:
В SQL можно подсчитать количество строк с помощью агрегатной функ-
ции count. Например, так:
select count(*) from student
Аналогичная возможность есть и в MongoDB, С помощью похожей функции
count() можно получить число элементов в коллекции. Например, количе-
ство документов в коллекции student можно подсчитать так:
50
Высшая школа цифровой культуры Университет ИТМО
db.student.count()
Так же, как и в SQL, есть возможность комбинировать условия поис-
ка и функцию count. Например, для того, чтобы подсчитать, сколько есть
студентов с именемAnna, в SQL мы напишем запрос
select count(*) from student where name = "Anna"
В MongoDB:
db.student.find({name: "Anna"}).count()
На рисунке приведен результат исполнения такого запроса среде MongoDB:
В коллекции могут быть документы, которые содержат одинаковые зна-
чения для одного или нескольких полей. Например, в нескольких документах
определеноname = "Kat".Апоусловиямзапросанадонайтитолькоуникаль-
ные различающиеся значения для одного из полей документа. Такую опера-
цию в математике называют операцией факторизации. Для этого в систе-
мах, управляющих хранением данных, принято использовать конструкцию
distinct. Напомним, что такая возможность существует и в SQL и исполь-
зуется, например, так:
select distinct name from student
Аналогичная возможность есть и в MongoDB. Запрос
db.student.distinct("name")
51
Высшая школа цифровой культуры Университет ИТМО
отображает список имен, которые встречаются в коллекции student. Причем
каждое имя будет отображаться в результате запроса только один раз.
На рисунке приведен пример исполнения такого запроса. Как видите –
повторяющихся имен нет.
52
Высшая школа цифровой культуры Университет ИТМО
4 Cassandra
4.1 Основы
В этом и последующих фрагментах данной лекции мы обсудим модель
данных в СУБД Cassandra и язык запросов Cassandra Query Language (CQL).
Почему именно Cassandra? Да просто потому, что это хранилище данных
считают наиболее ярким представителем группы колоночных хранилищ.
CQL во многих отношениях напоминает SQL, но, тем не менее, имеет
ряд важных отличий.
Для начала познакомимся с терминологией, используемой в СУБД
Cassandra. На первый взгляд, Cassandra кажется похожей на обычные ре-
ляционные СУБД. Например, в Cassandra тоже есть таблицы. Однако, в
Cassandra таблицей называется специальная логическая структура, объеди-
няющая похожие данные. Например, могут быть таблицы, представляю-
щие группу пользователей, студентов, отелей и т.п. В этом смысле табли-
ца Cassandra аналогична реляционной таблице. Принципиальное отличие со-
стоит в том, что в Cassandra нет необходимости хранить значения каждо-
го столбца (или поля) при сохранении новой сущности. Возможно, значения
53
Высшая школа цифровой культуры Университет ИТМО
некоторых столбцов неизвестны. Например, у одних людей есть второй номер
телефона, а у других - нет. Или в форме на странице сайта, реализованно-
го с использованием Cassandra, одни поля обязательны, а другие - нет. Это
нормально. Вместо того чтобы хранить значение null в качестве признака от-
сутствия значения и расходовать на это место, Cassandra вообще не хранит
соответствующее значение столбца для такой строки. При проектировании
таблицы в традиционной реляционной базе данных мы обычно имеем дело с
«сущностями»,т.е.наборамиатрибутов,описывающихнекоторыйобъект.Мы
не задумываемся о размере строк, потому что после того, как решение о том,
как объект представляется в виде таблицы, размер строки уже не подлежит
обсуждению. Но при работе с Cassandra размер строки фиксирован не так
жестко: строка может быть широкой или узкой в зависимости от количества
присутствующих в ней столбцов.
В Cassandra для представления широких строк, называемых также раз-
делами (partition), используется специальный первичный ключ. Его иногда
называют составным ключом (compound key). Составной ключ состоит из
ключа раздела (partition key) и необязательного набора кластерных столбцов
(clustering column). Ключ раздела (partition key) служит для определения уз-
лов распределенной системы, на которых хранятся строки. Ключ раздела мо-
жет состоять из нескольких столбцов. Кластерные же столбцы используются
для управления сортировкой данных при хранении внутри каждого раздела.
Основными структурами данныхв Cassandra являются: столбец, стро-
ка, таблица, пространство ключей и кластер. Познакомимся с ними поближе.
Итак, столбец в понимании Cassandra – это пара ключ-значение; строка – это
контейнер столбцов, на который можно сослаться по первичному ключу; таб-
лица – контейнер строк; пространство ключей – контейнер таблиц, а кластер
– контейнер пространства ключей, расположенных в одном или нескольких
узлах сети.
Это взгляд снизу вверх на модель данных Cassandra. Познакомившись
54
Высшая школа цифровой культуры Университет ИТМО
с основными терминами, перейдем к более детальному изучению каждой
структуры.
База данных Cassandra изначально спроектирована для распределения
данных между несколькими серверами, которые обрабатываются совмест-
но и представляются пользователю единым целым. Поэтому самая внеш-
няя структура в Cassandra называется кластером, или кольцом, потому что
Cassandra распределяет данные между узлами кластера, считая их заколь-
цованными.
Кластер – это контейнер пространства ключей. Пространство ключей
(keyspace) – самый внешний контейнер данных в Cassandra, во многом ана-
логичный реляционной базе данных. Как база данных является контейнером
таблиц в реляционной модели, так пространство ключей – контейнер таблиц в
модели данных Cassandra. Как и у реляционной базы данных, у пространства
ключей есть имя и набор атрибутов, определяющих его поведение в целом.
Таблица – это контейнер для упорядоченной коллекции строк, каж-
дая из которых, в свою очередь, представляет собой упорядоченную коллек-
цию столбцов. Порядок определяется столбцами, назначенными в качестве
55
Высшая школа цифровой культуры Университет ИТМО
ключей. В Cassandra могут существовать и дополнительные ключи, поми-
мо первичного. При записи данных в таблицу задаются значения одного или
нескольких столбцов. Эта коллекция значений называется строкой. Хотя бы
одно из заданных значений должно быть первичным ключом, который играет
роль уникального идентификатора строки.
Как проектируются модели данных в Cassandra? Прежде, чем начнем
проектировать модель данных для Cassandra, обратим внимание на ключе-
вые особенности проектирования. В Cassandra нет операций соединения. Со-
единение таблиц, если оно необходимо, приходиться производить на стороне
клиента, либо создавать дополнительную (т.е. денормализованную) таблицу
для хранения результатов виртуального соединения. При создании моделей
данных для Cassandra предпочтителен второй вариант. Соединение на сто-
роне клиента применяется очень редко, лучше продублировать (т.е. денорма-
лизовать) данные.
Несмотря на поддержку облегченных транзакций и пакетов совместно
выполняемых команд, в Cassandra нет понятия ссылочной целостности таб-
лиц. В реляционной базе данных мы можем определить в таблице внешний
ключ для ссылки на первичный ключ в другой таблице. В Cassandra такого
механизма нет.
При проектировании реляционной базы данных чрезвычайно важным
фактором считается нормализация таблиц (т.е. чтобы данные в таблицах не
повторялись многократно и т.п.). Но при работе с Cassandra это вовсе не
считается преимуществом, потому что оптимальная производительность в
Cassandra достигается тогда, когда модель данных денормализована. Порою
56
Высшая школа цифровой культуры Университет ИТМО
и в реляционной базе приходится идти на денормализацию, и тому есть две
причины.
Первая – производительность. Разработчику программного обеспечения
попросту не удается добиться нужной производительности, если необходимо
соединять накопившиеся за много лет данные, поэтому он производит де-
нормализацию, подстраиваясь под нужды известных запросов. Этот подход
работает, но идет вразрез с идеологией реляционной модели, так, что, в конце
концов, возникает вопрос, а является ли реляционная база оптимальным ре-
шением в данных условиях.Вторая причина намеренной денормализации –
структура документа, нуждающегося в длительном хранении. То есть имеет-
ся основная таблица, которая ссылается на много внешних таблиц, данные в
которых со временем изменяются, однако необходимо сохранить для истории
документ в том виде, в котором он существовал в момент создания.
Типичный пример – счета-фактуры. У нас уже есть таблицы заказчиков
и продуктов, и, казалось бы, счет-фактура может просто сослаться на эти
таблицы. Но на практике так никогда не делается. Информация о заказчике
57
Высшая школа цифровой культуры Университет ИТМО
или ценах может измениться, да сама форма и количество полей в счете фак-
туры может измениться и тогда будет нарушена целостность счета-фактуры
в том виде, в котором она существовала на момент создания. А это приведет
к ошибкам при аудите, в отчетах, к нарушению законов и прочим проблемам.
В реляционном мире денормализация нарушает классические принципы Код-
да, и, поэтому, этого стараются избегать. Но в Cassandra денормализация –
типичный прием и считается совершенно нормальным делом. Если модель
простая, то денормализовывать ее не обязательно. Но и бояться этого не на-
до.
Но, вернемся к особенностям проектирования моделей данных в
Cassandra. Еще одно важное отличие состоит в методике проектирования
от запроса. Говоря простыми словами, реляционное моделирование означа-
ет, что мы начинаем с концептуальной модели предметной области, а затем
представляем сущности, оказавшиеся в этой модели, таблицами. После этого
назначаются первичные и внешние ключи для моделирования связей. Свя-
зи многие-ко- многим представляются связующими таблицами. В реальном
мире связующим таблицам ничего не соответствует, это просто необходимый
побочный эффект построения реляционных моделей. Определившись с таб-
лицами, мы начинаем писать запросы, в которых данные из разных таблиц
связываются с помощью ключей. В реляционном мире запросы – вещь вто-
ричная. Предполагается, что если таблицы спроектированы правильно, то уж
данные мы как-нибудь достанем. И обычно это – правда, даже если для реше-
ния задачи приходится прибегать к сложным подзапросам или соединениям.
Напротив, в Cassandra мы начинаем не с модели данных, а с модели запросов.
Вместо того, чтобы сначала построить модель данных, а затем писать запро-
сы, при работе с Cassandra мы сначала продумываем запросы, а уже вокруг
58
Высшая школа цифровой культуры Университет ИТМО
них организуем данные. Решите, какие запросы чаще всего будут предъяв-
ляться в приложении, а затем создавайте таблицы, поддерживающие их эф-
фективное выполнение. Критики высказывают мнение, что проектирование
от запросов чрезмерно ограничивает область применимости приложения, не
говоря уже о моделировании базы данных. Но разве не разумно предполо-
жить, что мы обязаны продумать запросы приложения не менее тщательно,
чем обдумываем особенности предметной области. Допустив ошибку, мы по-
лучим проблемы и в том, и в другом случае. Со временем запросы могут
измениться, и тогда придется изменить структуру данных. Но это ничем не
отличается от неправильного определения таблиц или необходимости добав-
ления новых таблиц в РСУБД.
В реляционных базах структура хранения таблиц на диске обычно про-
зрачна для разработчика, и в контексте моделирования данных редко мож-
но встретить рекомендации, касающиеся физического хранения таблиц. Но в
Cassandra это важный аспект. Поскольку каждая таблица хранится в отдель-
ном файле, важно, чтобы взаимосвязанные столбцы были определены вместе
в одной и той же таблице. При проектировании модели данных в Cassandra
важно минимизировать количество разделов, которые нужно просматривать
при обработке запроса. Поскольку каждый раздел целиком расположен толь-
ко на одном узле, быстрее всего выполняются запросы, которым нужно про-
сматривать только один раздел.
Еще одна важная особенность в проектировании – учет сортировки дан-
ных в запросах. В РСУБД порядок, в котором возвращаются записи, легко
изменить,включиввзапросфразуORDERBY.Порядоксортировкипоумол-
чанию не задается, и в отсутствии других указаний записи возвращаются в
том порядке, в котором добавлялись. Чтобы изменить порядок сортировки,
нужно всего лишь модифицировать запрос, причем сортировать можно по
любому набору столбцов. Но в Cassandra к сортировке отношение другое: ре-
шение о ней принимается на этапе проектирования. Порядок сортировки в
59
Высшая школа цифровой культуры Университет ИТМО
запросе фиксирован и определяется, так называемыми, кластерными столб-
цами, заданными в командеCREATE TABLE. КомандаSELECT (которая также
есть в Cassandra) поддерживает семантикуORDER BY, но только в порядке,
определяемом кластерными столбцами.
В следующих фрагментах данной лекции познакомимся с приемами
моделирования базы данных Cassandra и языком запросов CQL(Cassandra
Query Language).
4.2 Проектирование модели данных
Для того, чтобы поближе познакомится с упомянутыми в предыдущем
фрагменте принципами, попробуем построить модель данных для какого- ни-
будь конкретного приложения. Для начала опишем простую модель предмет-
ной области, вполне понятную в реляционном мире, а затем посмотрим, как
перейти от реляционной модели к модели, принятой в Cassandra. Для этого
примера нам понадобится нечто такое, что позволило бы продемонстрировать
различные структуры данных и паттерны проектирования, но не настолько
сложное, чтобы погрязнуть в деталях. К тому же предметная область должна
быть всем знакома, чтобы сосредоточиться на особенностях Cassandra, а не
на описании того, что мы пытаемся смоделировать. Подходящим примером
можно считать создание модели для приложения, предоставляющего различ-
ную информацию о некой базе данных с сотней лучших мультфильмов.
В концептуальной модели данных будут присутствовать названия мульт-
фильмов, годы выпуска, страна происхождения, продолжительность, количе-
ство просмотров и режиссеры, принимавшие участие в создании мультфиль-
мов. Мы уже упоминали эту предметную область ранее, но, тем не менее,
60
Высшая школа цифровой культуры Университет ИТМО
продемонстрируем структуру данных соответствующей предметной области
в виде ER-модели, как это принято при проектировании реляционных баз
данных.
Теперь попробуем применить подход проектирования от запроса к этим
же данным. Структура проектируемого пользовательского интерфейса ча-
сто помогает, когда мы начинаем продумывать, какие необходимы запросы.
Предположим, что мы переговорили со всеми заинтересованными сторонами,
и дизайнеры предложили набросок интерфейса для основных выявленных
сценариев использования.
Потом мы подготовим примерно такой список запросов, который вы ви-
дите на слайде. Какие именно это запросы:
1. Выдать названия мультфильмов по стране выпуска (результат отсор-
тировать по количеству просмотров).
61
Высшая школа цифровой культуры Университет ИТМО
2. Для выбранного мультфильма выдать его продолжительность и год вы-
пуска.
3. Для выбранного мультфильма указать список режиссеров.
4. Для выбранного режиссера указать названия его мультфильмов и ко-
личество просмотров (результат отсортировать лексикографически по
названиям мультфильмов).
Теперь обсудим, какие логические таблицы должны подойти для этих
сформулированных запросов.
Мы назвали первую таблицуCARTOON_BY_COUNTRY, чтобы отразить тот
факт, что мультфильм будет выбираться по стране выпуска и определили ко-
лонки Country и Cartoon_id как ключевые (то есть входящие в состав ключа
раздела). Мы включили в состав ключа колонкуCountry, так как по ней бу-
дет происходить запрос и добавили к ней колонкуCartoon_id для того, что-
бы гарантировать, что такой составной ключ будет с одной стороны полезен
для быстрого выполнения запроса, а с другой стороны – он будет однознач-
ным образом идентифицировать запись в таблице. Кроме того, мы указали,
что колонкаViews – кластерная колонка и уточнили, что сортировка по кла-
стерной колонке будет по убыванию. Оставшуюся колонку (Cartoon_name)
включили для отображения в результате запроса.
Мы называли вторую таблицуCARTOON_BY_ID, чтобы отразить тот факт,
что мультфильм будет выбираться по его уникальному идентификатору и
включили в состав ключа раздела колонкуCartoon_id. Остальные колон-
ки Cartoon_name, Year и Duration включены для отображения в результате
запроса.
62
Высшая школа цифровой культуры Университет ИТМО
Мы называли третью таблицу – DIRECTOR_BY_CARTOON_ID, чтобы от-
разить тот факт, что режиссеры будут выбираться по уникальному иден-
тификатору мультфильма и включили в состав ключа раздела колонки
Cartoon_id и Director_id. Таким образом, мы обеспечили базу для быст-
рого выполнения запроса и уникальность ключа для идентификации записей
в таблице. Оставшуюся колонкуDirector_name включили в состав таблицы
для отображения в результате запроса.
Мы назвали четвертую таблицу –CARTOON_BY_DIRECTOR_ID, чтобы от-
разить тот факт, что мультфильмы будут выбираться по уникальному
идентификатору режиссера и включили в состав ключа раздела колонки
Director_id и Cartoon_id. Кроме того, колонкаCartoon_name была опре-
делена, как кластерная и для нее указана требуемая сортировка – по возрас-
танию.
63
Высшая школа цифровой культуры Университет ИТМО
Следующим шагом после определения логической структуры таблиц бу-
дет построение физической модели данных. В несколько упрощенном вари-
анте построение можно разбить на три этапа. На первом – определяются
первичные ключи для таблиц, на втором – создаются пространства ключей,
анатретьем–определяютсявозможныетипыданныхдляколонокитаблицы
сопоставляются подходящим пространствам ключей.
Очередной этап проектирования – создание пространства клю-
чей. Однако до того, надо определить какие пространства и в ка-
ком количестве понадобятся в принципе. В нашем случае представля-
ется уместным создать два пространства ключей: Cartoon и Director.
В первом будут располагаться две логически связанные между со-
бой таблицы: CARTOON_BY_COUNTRY, CARTOON_BY_ID, а во втором –
DIRECTOR_BY_CARTOON_ID и CARTOON_BY_DIRECTOR_ID.
64
Высшая школа цифровой культуры Университет ИТМО
На следующем слайде демонстрируется, как можно определить про-
странствоключей.Небудемдетализироватьзадаваемыехарактеристикипро-
странства ключей, а лишь поясним, что они задают особенности механизма
репликаций и количество создаваемых реплик.
Далее нужно определить типы колонок и привязать таблицы к подхо-
дящим пространствам ключей. Мы не будем подробно рассматривать все
возможные типы колонок в Cassandra. В рамках одной лекции это просто
невозможно. Любознательные слушатели легко смогут найти соответствую-
щую информацию в открытой документации Cassandra. Для нашего примера
вполне достаточно представлять, что есть три простейших типа: текстовый,
целочисленный и короткий целочисленный. Именно их мы будем использо-
вать при построении базы.
Итак, добавим к логической таблице CARTOON_BY_COUNTRY типы коло-
нок, чтобы в затем определить таблицу на языкеCQL. Определение типов –
достаточно несложная операция. Страна – текстовое поле, идентификатор
мультфильма – короткое целое, название фильма – текстовое, количество
просмотров – целое.
65
Высшая школа цифровой культуры Университет ИТМО
Вот как на языке CQL выглядит оператор, создающий новую таблицу.
Обратите внимание, чтоPRIMARY KEY образуется из всех полей, объявленных
как поля из ключа раздела плюс кластерные поля. В нашем случае – это три
поля: Country, Cartoon_id, Views. Кроме того, в предложенииCREATE TABLE
встречается фрагментWITH CLUSTERING ORDER BY, который явным образом
указывает возможную сортировку в таблице по полюViews. И наконец, пе-
ред именем таблицыCARTOON_BY_COUNTRY указано имя пространства ключей
Cartoon, в котором будет размещена таблица.
66
Высшая школа цифровой культуры Университет ИТМО
Далее определим типы для таблицы CARTOON_BY_ID: идентификатор
мультфильма – короткое целое, год выпуска фильма – короткое целое, на-
звание фильма – текстовое, продолжительность фильма – целое.
На экране можно видеть, как будет выглядеть операторCREATE TABLE,
создающий таблицу CARTOON_BY_ID. Обратите внимание, что первичный
ключ имеет простейший вид, так как образуется из единственной колонки –
идентификатор мультфильма, а перед именем таблицыCARTOON_BY_ID ука-
зано имя пространства ключейCARTOON, в котором будет размещена таблица.
67
Высшая школа цифровой культуры Университет ИТМО
На следующем слайде определение типов для таблицы
DIRECTOR_BY_CARTOON_ID: идентификатор мультфильма – короткое це-
лое, идентификатор режиссера – короткое целое, имя режиссера – текстовое.
А вот и операторCREATE TABLE для таблицыDIRECTOR_BY_CARTOON_ID.
Как видите – первичный ключ образуется из идентификаторов мультфильма
и режиссера, а перед именем таблицыDIRECTOR_BY_CARTOON_ID указано имя
пространства ключейDIRECTOR, в котором будет размещена таблица.
68
Высшая школа цифровой культуры Университет ИТМО
И, наконец, определение типов для таблицыCARTOON_BY_DIRECTOR_ID:
идентификатор режиссера – короткое целое, идентификатор мультфильма –
короткое целое, название мультфильма – текстовое, количество просмотров
– целое.
И последний оператор CREATE TABLE для таблицы
CARTOON_BY_DIRECTOR_ID. Первичный ключ здесь образуется из иден-
тификаторов мультфильма и режиссера, но, кроме этого, в него включается
кластерное поле CARTOON_NAME. Кроме того, в предложении CREATE TABLE
встречается фрагментWITH CLUSTERING ORDER BY, который явным образом
указывает возможную сортировку в таблице по полю CARTOON_NAME, а
перед именем таблицыCARTOON_BY_DIRECTOR_ID указано имя пространства
ключей DIRECTOR, в котором будет размещена таблица.
69
