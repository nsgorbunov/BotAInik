В 2023 году ChatGPT стал самой узнаваемой языковой моделью машинного обучения во всём мире — причём как среди специалистов, так и среди обычных людей.
Способность вести осмысленный диалог, отвечать на практически любые вопросы и быть применимыми без дообучения в большом спектре задач с высоким качеством — вот залог их  популярности.
В этом параграфе мы расскажем, что такое языковые модели, как они устроены, как развивались, а также как изменились за последнее время.
Что такое языковые модели?Что такое языковые модели?
Говоря простым языком, языковые модели — это алгоритмы, способные продолжать тексты. Если чуть усложнить, то это вероятностные алгоритмы, и к ним сразу можно задать эмпирический критерий качества: хорошая модель даёт разумные продолжения данных ей текстов.

Давайте разберём пример выше.
Модель высчитывает вероятность возможных продолжений текста и предлагает их нам. Слово «фрукт» — наименее разумное продолжение нашей фразы, в то время как слово «наука» — наиболее разумное. И действительно, это часть определения машинного обучения, которое мы давали в начале этого учебника.
Таким образом, нам осталось лишь научить алгоритм моделировать эти вероятности и максимизировать их для разумных предложений. Но как это сделать? По ходу развития языковых моделей подходы менялись, мы расскажем о каждом из них в хронологическом порядке.
Начнём с краткого экскурса в историю — поговорим о статистических моделях, рекуррентных нейронных сетях и трансформерах. А затем перейдём к современным — GPT-1, GPT-2, GPT-3, InstructGPT, ChatGPT и LLaMa.
Развитие языковых моделейРазвитие языковых моделей
Статистические моделиСтатистические модели
Идея модели лежит на поверхности, много где применяется в самых разных вариациях даже в ХХ веке, поэтому сложно назвать авторов или точную дату создания. Однако этот метод популярен до сих пор — используется в клавиатурах смартфонов для исправления опечаток и быстрого набора текстов через Т9.
Теперь подробнее о методе.
Напомним вероятностную формулировку цепей Маркова в общем виде:
Если представить, что   — это слово, а набор этих омега — это предложение, то по формуле становится возможным посчитать вероятность предложения  С практической точки зрения всё чуть сложнее, ведь распределение слов в реальном языке (какое, с какими и как часто встречается), вообще говоря, неизвестно.
Его принято аппроксимировать на основе корпуса текстов (например, всего интернета) — в этом случае считаются совстречаемости слов друг с другом, и по ним считаются вероятности.
В условной вероятности число переменных, от которых зависит распределение следующего слова, называется контекстом. Например, в выражении  длина контекста равна . На практике же редко считают вероятности с контекстом больше трёх, на это есть несколько причин:

Сложность в подсчёте и хранении каждого возможного уникального контекста длины . Если корпус текстов состоит из   различных слов, то стоимость хранения счётчиков встречаемости для выбранной длины контекста равна , что очень много при больших .
Большой контекст реже встречается. То есть слова «яблоку», «негде» и «упасть» поодиночке встречаются чаще, чем их комбинация «яблоку негде упасть». Отсюда достаточность статистик падает с ростом длины контекста.

В учебном примере предлагается ограничиться шириной контекста размера 1:

Интересно, что такой подход достаточно популярен до сих пор. Например, он используется в умных клавиатурах, чтобы подсказать следующее слово.
Достоинства статистических моделей:

Простота имплементации.
Высокая скорость работы алгоритма.
Низкая вычислительная стоимость обучения и инференса.

Недостатки статистических моделей:

Не сможет сгенерировать слова, которые не шли подряд в обучающем корпусе.
Очень маленький контекст.
Длинные последовательности равновероятны ≈ нулю (в цепях Маркова для длинных последовательностей много множителей меньше нуля, поэтому их произведение уже практически равно нулю для любых множителей). Отсюда алгоритм не может выдавать разумные продолжения большой длины.

ТокенизацияТокенизация
Языковые модели, да и вообще все модели, которые оперируют текстом, используют понятие токена. Токен — это единица текста, которую понимают алгоритмы. В примере выше токен — это отдельное слово  (этот подход называется мешком слов), однако текст можно разбивать на токены и иначе.

Раньше предложение разбивалось на слова по пробелам, знакам препинания, исключались стоп-слова и так далее (назовем это CountVectorizer). Но у этого подхода возникали две проблемы с разными словоформами. Они:

Либо обозначались разными токенами, что не совсем верно, ведь слово-то одно и то же. И получалось, что похожим смыслом обладало сразу несколько токенов.
Либо приводились к начальной форме — и в итоге терялся падеж, время, число.

Современные токенизаторы построены на алгоритме BPE (Byte Pair Encoding; об устройстве BPE более подробно можно прочитать в учебнике Лены Войта). Решение требует фиксации определённого числа токенов. Как только это сделано, в словарь добавляются все символы из текста, ищутся самые частые их сочетания и снова добавляются. Этот процесс продолжается до тех пор, пока число токенов не станет равно заданному значению.
Токенизатор SentencePiece в определённом смысле совершеннее, чем BPE, — он наследует логику Unigram- и BPE-токенизаторов, иначе работает с пробелами (добавляет _  перед соответствующим токеном) и не построен на логике разбиения слов по разделителям.
Поэтому, в отличие от BPE, он способен работать с такими языками, как японский или китайский. Подробнее о его устройстве можно прочитать здесь.

💡 Токенизаторы не разделяют входной поток по значимости. Например, число 12345 BPE могут разбить на два токена — 1 и 2345, что явно не соответствует логике написанного выражения. Также они будут неправильно выделять всё число в отдельный токен, так как чисел бесконечное количество. Сейчас используется идея о разбиении всех чисел на цифры, чтобы множеством из десяти токенов представить всё многообразие чисел.

Рекуррентные нейронные сети (RNN)Рекуррентные нейронные сети (RNN)
Появились после статистических моделей, подробнее о хронологии здесь. Рекуррентные нейронные сети концептуально можно описать формулой, где:
 — некоторая модель;
  — внутреннее состояние модели на момент времени ;
 — токен, который сейчас обрабатывается.
Тогда следующий токен  получается так:



ссылка на источник картинки


Подробно об устройстве RNN мы рассказываем в параграфе Нейросети для работы с последовательностями. Здесь же коротко отметим, что существуют различные модификации рекуррентных сетей, которые усложняют структуру алгоритма , даже добавляют механизм внимания Attention. Если коротко, то он позволяет лучше оценивать взаимосвязи токенов в тексте. Все они в разной степени помогают модели усваивать более длинные и сложные последовательности токенов.
Достоинства RNN:

Высокая скорость инференса и сравнительно низкая стоимость.
Более качественный текст, чем у моделей на статистиках.
Теоретически понимает контекст в сотни слов (а с Attention ещё больше).
Точно учитывает весь контекст документа.

Недостатки RNN:

Невозможность параллельного обучения на многих устройствах, отсюда не получится просто так обучить большую RNN.
Модель «хорошо помнит» лишь несколько последних токенов контекста (без Attention).
Проблемы с обучением (exploading/vanishing gradients).

ТрансформерыТрансформеры
Более подробно трансформеры и их устройство описаны в параграфе Трансформеры. Последней и наиболее успешной с точки зрения качества оказалась архитектура трансформеров. Она состоит из двух частей: encoder (на изображении слева) и decoder (на изображении справа).



ссылка на источник картинки


Изначально был популярен подход обучать части отдельно. Так на базе encoder-блоков были построены BERT-модели. Идея обучения звучит несложно: давайте из входного текста замаскируем токеном MASK 15% имеющихся токенов и обучим модель угадывать, какие именно токены были скрыты. Тогда, если модель обучится это делать, она сможет очень хорошо понимать текст.
Таким образом, энкодеры обладают следующими особенностями:

Анализируют входной текст и связи между токенами.
Выделяют важные токены для определённой задачи.
Ничего не генерируют.

На базе декодеров сделаны GPT-модели. Они обучаются предсказывать следующий токен на основе предыдущих. На инференсе, когда очередной токен сгенерирован, он добавляется в контекст, и уже на основе него выбирается новый токен. Таким образом модель:

генерирует токен за токеном.
смотрит на весь контекст, архитектурно, нет забывания токенов.
имеет возможность (как и BERT-модели) обучаться параллельно.
обладает достаточно высокой вычислительной стоимостью инференса.


💡 Контекст в случае трансформеров определяется числом токенов, которые они могут обработать за раз. Архитектурно за понимание контекста отвечает блок Attention, и размеры матриц в нём как раз определяют размер контекста. 
Размер матриц конечен: чем они больше, тем сложнее вычислять блок внимания, поэтому контекст существенно ограничен. На момент написания параграфа разработаны различные модификации Attention, позволяющие растить понимаемый контекст, однако они имеют ряд проблем, с которыми предлагаем ознакомиться читателю самостоятельно.

Современные подходыСовременные подходы
GPT-1 & GPT-2GPT-1 & GPT-2
Начнём немного издалека, с моделей GPT-1 и GPT-2.
Первая была обучена в 2018 году на 7000 книг и имела размер контекста в 512 токенов. И она сразу получилась довольно сильной: после дообучения на специализированные задачи (бенчмарки) показывала на них лучшее на то время качество.
Так, в задачах CoLA (бенчмарк классификационный, в нём надо определить грамматическую корректность предложения) результат вырос до 45,4 против прежнего результата в 35,0 у RNN. А в GLUE — с 72,8 до 68,9.
Вторая модель была обучена в 2019 году. Она состояла из рекордных для того времени 1,5 млрд параметров (то есть была в ~10 раз больше первой), имела контекст в 1024 токена и была обучена на 40 ГБ текстовых данных. GPT-2 снова побеждала предыдущие подходы, включая GPT-1, на многих бенчмарках.
По сравнению с первой версией модели у второй произошел качественный рост: теперь она могла генерировать разумные тексты — а не только предложения. Правда, не всегда и не с первой попытки.
GPT-3GPT-3
GPT-3 стала революцией с точки зрения качества и размеров. В 2020 году была получена модель размером в 175 млрд параметров, она обучалась на 570 ГБ текстовых данных с контекстом в 2048 токенов. Модель могла решать целый спектр задач, включая перевод, суммаризацию и ответы на вопросы, с качеством, близким к человеческому уровню, а также отличалась высокой способностью генерировать креативный контент. Демонстрацию работы модели лучше посмотреть в этой статье на 28 странице и далее.



Модель
Число обучающих данных
Контекст
Число параметров
Decoder-слои
Hidden-size (размерность тензоров внутри модели)
Train batchsize (размер батча при обучении)




GPT
7000 книг
512
117 млн
12
768
64


GPT-2
40 ГБ текстовых данных
1024
1,5 млрд
48
1600
512


GPT-3
570 ГБ текстовых данных
2048
175 млрд
96
12 288
3 200 000



Модель демонстрировала действительно впечатляющие результаты: собрав обучающие данные, можно было с высоким качеством решить практически любую текстовую задачу.
Однако для применения таких решений остаётся проблема со стоимостью их обучения. Для обучения GPT-2 авторы использовали 16 GPU (иначе говоря — графических процессоров, видеокарт), а для GPT-3 уже 3200. Для дообучения модели под определенную задачу, конечно, понадобится меньше ресурсов, но всё равно достаточно много.
Что с этим делать? Использовать подводки.
ПодводкиПодводки
Few-shot обучениеFew-shot обучение
Оказывается, что обучать большие языковые модели решать определённые задачи не всегда нужно (как мы говорили ранее, это ресурсоёмко): можно составить few-shot подводку. Подводка — словесное описание поставленной задачи, составленное определенным образом.
Представим, что мы хотим осуществить перевод с английского на французский. Для обучения нам необходимо было бы составить пары , где  — слово на английском, а  — на французском. Сделаем иначе — опишем задание на естественном языке:



ссылка на источник картинки


Здесь на английском языке сформулировано задание и предлагается слово «cheese» перевести на французский. Назовем такую конструкцию zero-shot-примером. Такой запрос GPT-3, возможно, поймёт, но работать будет плохо.
Давайте увеличим количество примеров в подводке и назовем эту конструкцию one-shot:



ссылка на источник картинки


Или больше, и это будет few-shot:



ссылка на источник картинки


При этом приёме не тратятся ресурсы на обучение модели, она лишь смотрит на контекст и генерирует продолжение. Оказывается, этого достаточно, чтобы сравняться с downstream-обучением. Продемонстрируем преимущество такого подхода на двух бенчмарках.

TriviaQA — вопросно-ответный бенчмарк, составленный на основе Википедии. Он помогает оценивать знания модели и ее ответы на вопросы.
Lambada — оценивает меморизацию длинного контекста модели. Чем выше скор, тем лучше модель на обоих бенчмарках.




ссылка на источник картинки





ссылка на источник картинки


Графики выше демонстрируют несколько особенностей:

Few-shot позволяет получать качество, сравнимое с дообучением на определённом датасете, и стремится к человеческому качеству.
С ростом числа обучаемых параметров модели растет её качество.
На правом графике few-shot-примеры начинают работать лучше zero-shot-примеров лишь с некоторого размера модели. Это говорит о том, что модель начинает демонстрировать «умные» свойства лишь начиная с некоторого размера.


💡 На самом деле последний пункт достаточно часто встречается в языковых моделях. Случается так, что определённые приёмы не работают с маленькими моделями, но показывают себя лишь на больших. 
Это можно назвать фазовым переходом, когда языковая модель вместе с увеличением размера и числа пройденных текстов на обучении обретает большую обобщающую способность.

Формулировка имеет значениеФормулировка имеет значение
Few-shot действительно полезен и помогает получать от модели нужный результат без обучения, но всё же недостаточно хорошо.
Предположим, мы хотим узнать у модели, как приготовить любимое блюдо. Пусть это будет лазанья:

Можно заметить, что запрос к модели можно задать по-разному, но ответ ожидается обычно какой-то конкретный. Авторы этой статьи заметили, что сама по себе конструкция few-shot-примера не приводит к стабильному результату. Качество решения задачи очень зависит от:

Текстового описания задачи.
Числа примеров в подводке.
Порядка, в котором примеры следуют друг за другом в подводке.
Формате составления few-shot.

Чтобы улучшить качество решения задачи, авторы предлагают осуществлять калибровку подводок. В статье они заметили, что модели смещены относительно подводок, то есть переформулировка запроса ведёт к смещению в ответе модели, а также к росту разброса ответов.
Например, модели задают вопрос и её задача — ответить «да» или «нет». Если few-shot состоит из четырёх примеров и они идут в порядке «да», «да», «нет»,  «нет», то, вероятнее всего, дальше модель ответит «нет» на любой вход, просто потому что слово «нет» встречалось последним.
Калибровать модель предлагается с помощью выученного линейного преобразования:
В этом преобразовании:
 и  — обучаемые;
 — вероятности на выходе модели;
 — откалиброванные вероятности;
Обучающие данные собираются так:



ссылка на источник картинки


Для различных задач собираем подводки и добавляем нейтральное слово N/A. В этом примере несмещённая модель должна давать с вероятностью 50% ответ «positive» или «negative».
Чтобы добиться такого распределения ответов у смещённой модели, представим:
Также все few-shot-примеры стандартизуются в специальный формат вопрос — ответ, как на картинке выше.
Этот метод (синий график) по сравнению со стандартными few-shot-примерами (красный график) помог повысить качество и уменьшить разброс результата. Таким образом, оптимизировав всего 4 параметра, авторы существенно улучшили итоговый результат.



ссылка на источник картинки


Promt-tuningPromt-tuning
Качество работы модели зависит от подводки, и few-shot просто один из способов её построения. Эксперименты показывают, что грамотный подбор промта позволяет экономить на обучении и решать задачи с высоким качеством. Проблема в обучении больших моделей — нехватка оперативной памяти на GPU, поэтому не будем оптимизировать все параметры модели.
Пусть необходимо решить задачу , к ней имеется обучающее множество вида . Введём дополнительные токены, которых не было в словаре:  — и будем добавлять в каждый текст из X согласно какому-то правилу.
Правило может быть таким: имеем 20 спецтокенов, добавим токены 1–10 в начало строки, а 11–20 в конец.
Тогда, можно «заморозить» все параметры в модели, кроме этих токенов, и сэкономить на обучении. Если токенов 100 и каждый из них имеет размерность в 1024, то необходимо оптимизировать лишь 100 тысяч параметров вместо 175 млрд в случае обучения всей модели.



ссылка на источник картинки



💡 Эффект от такого трюка достаточно многогранен:

Меньше обучаемых параметров — меньше памяти занимает модель.
Меньше обучаемых параметров — быстрее происходит обучение.
Обычно нужно сильно меньше обучающих данных, чем при традиционном обучении всей модели для достижения высокого качества.
Высокое качество результата.


Получается, что можно оптимизировать подводку, или, другими словами, находить наиболее оптимальный промт, который лучше прочих решает поставленную задачу.
Как повысить качество решения задач из разных категорийКак повысить качество решения задач из разных категорий
Языковые модели призваны решать самый широкий спектр текстовых задач — вопросно-ответные, суммаризацию, диалоговость, перевод и многие другие.
Получается, что модель должна после некого обучения (подбора подводки или оптимизации вообще всех параметров под каждую задачу) решать каждую из них на высоком уровне. Однако модель обычно учится на текстах из интернета, книгах и других доступных ресурcах. И формат задачи, который обычно требуется от модели, не соответсвует тому, что алгоритм привык видеть на обучении. К этому стоит добавить, что среди веб-документов просьба что-то сократить или определить тональность документа встречается не очень часто.
Исправить этот недостаток призваны подходы по генерализации языковых моделей: FLAN и T0. Инструкции даются на естественном языке и для подготовки качественного обучающего множества предлагается произвести следующие действия:

Каждой отдельной задаче (будь то перевод, написание отзывов или суммаризация) пишется по несколько различных подводок, отражающих смысл задания.
Итоговый датасет составляется из отдельных задач, все строчки датасета перемешиваются случайным образом.
Авторы стараются собрать как можно более разнообразные задачи в обучающее множество.




ссылка на источник картинки





ссылка на источник картинки





ссылка на источник картинки


Две картинки сверху демонстрируют FLAN- и T0- подходы по созданию датасета, а картинка снизу — рост усреднённого качества модели после обучения на смеси. Таким образом с некоторого размера модели наблюдается повышение метрик качества при дальнейших дообучениях генерализованной модели на отложенных задачах.
Chain-of-ThoughtChain-of-Thought
Предыдущий подход со смесью датасетов помогает решать многие задачи в среднем заметно лучше. Однако есть задачи, где качество результатов модели всё ещё низкое. Например, предложить эффективный код, решающий некую алгоритмическую задачу, найти минимум некоторой аналитической функции потерь, посчитать производную фукнции в точке и так далее.
Такие вопросы требуют рассуждения, которое модель не может просто так провести из-за своей архитектуры. Выход — составить подводки в стиле Chain-of-Thought (CoT):



ссылка на источник картинки


CoT-подводка состоит из трёх обязательных элементов:

Формулировки задачи на естественном языке.
Подробного пошагового решения.
Ответа на задачу.

Формирование такого промта, особенно на few-shot, заставляет модель рассуждать, как можно правильно решить задачу. Авторы этой статьи сравнили на двух математических бенчмарках способность модели решать сложные задачи.

MultiArith — проверяет умение решать простые арифметически задачки.
GSM8K — более сложные.

Результаты демонстрируют, что наличие CoT в подводке увеличивает способность решать математические задачки у больших языковых моделей.

InstructGPTInstructGPT
Наконец, обсудив, как готовить обучающие данные, перейдем к прародителю ChatGPT. Инструкционная модель — это та, которая обучена отвечать на пользовательские запросы в режиме zero-shot (а вообще, и few-shot, и любой человекочитаемый формат) с высоким качеством.



ссылка на источник картинки


InstructGPT — это модель, и она интересна с точки зрения выработки концепции обучения всех инструкционных моделей (InstructGPT, ChatGPT, GPT-4 и других). С некоторыми нюансами обучение состоит из четырех этапов:

Подготовка качественного претрейна. Языковая модель должна содержать в себе как можно больше знаний о мире, чтобы иметь возможность в последующем решать произвольные задачи с высоким качеством. На этом этапе необходимо озаботиться наибольшим разнообразием, чистотой и полнотой обучающих данных. Подробнее об этом мы поговорим в последнем разделе этого параграфа.
SFT (supervised finetuning) — обучение модели следовать инструкциям. Этот пункт мы подробно обсудили в предыдущей части параграфа (T0, FLAN, CoT). На этом этапе важно составить грамотный инструкционный датасет, где инструкция содержит произвольные запросы к модели, а ответ на неё — подробный текст, которым будущий пользователь будет доволен. Грамотный сбор таких данных довольно дорогостоящий процесс, но от него напрямую зависит, каким образом модель будет взаимодействовать с пользователем.
Обучение reward-модели. Каждый ответ алгоритма можно оценить с точки зрения вежливости, подробности или персонажности. Персонажность позволяет модели считать себя, например, капитаном Джеком Воробьем и общаться на пиратском говоре. Также есть менее формализуемые критерии качества ответов, их даже сложно описать словами. Например, что в основном людям ответ 1 нравится больше чем ответ 2.
Reward-модель агрегирует эти кртитерии в число — меру качества. Чем оно выше, тем качественнее ответ модели. Для выравнивания поведения модели обычно важно уметь оценивать тысячи текстов, а вручную это делать дорого и долго, поэтому обучается специальная модель-оценщик. Про то, как обучать reward-модель, будет рассказано далее.
Этап Reinforcement Learning (RL). На нём языковая модель обучается генерировать такие ответы, которые имели бы наивысшую оценку относительно reward-модели. Про то, как делать RL, будет рассказано далее.

ChatGPTChatGPT
Одна из самых нашумевших языковых моделей в мире наследует логику обучения Instruct GPT. Основные отличия от последней заключаются в:

Диалоговости. Модель обучена работать с диалогами, держать их в контексте и помнить историю того, что требовал пользователь. Обучение производится посредством сбора/написания диалоговых данных.
Размере и качестве инструкционного датасета.
Том, что больше внимания уделено разметке и обучению reward-модели и этапу с RL.

К сожалению, OpenAI не предоставили детали обучения ChatGPT, а предложили лишь общий ход действий. Также неизвестны архитектурные параметры модели.
Как обучить свою LLM?Как обучить свою LLM?
Обсудим детально на примере доступных в open-source моделей семейства LLaMA.
LLaMaLLaMa
В качестве примера возьмём самую свежую архитектуру трансформеров на первую половину 2023 года — LLaMa, а также способы превращать её в чатовую модель, проводить Alignment на примере LLaMa-2. Вторая модель архитектурно не отличается от первой (кроме увеличенного контекста до 4096 токенов), поэтому содержание статей можно объединить в один рассказ.
ПретрейнПретрейн
Для обучения с нуля качественной языковой модели необходимы:

мощный кластер на сотни видеокарт, на котором можно производить параллельное обучение модели. Больше GPU — больше модель можно обучить и быстрее по времени обучения;
терабайты текстовых данных для тренировки на них;
архитектура, которая лучшим образом может моделировать язык.

Поговорим подробнее о двух последних пунктах.
Текстовые данные
Текстовые данные можно брать из открытых источников, таких как CommonCrawl, C4, Taiga и прочее. Важно обеспечить:

чистоту данных — например, убрать html-тэги, устранить дублирование текстов;
полноту — чтобы модель одинаково хорошо решала математические задачи, писала код или сочиняла стихотворения, текстов соответствующих доменов должно быть в достатке в обучающем корпусе;
разнообразие данных.

Существуют эмпирические законы обученности модели, но здесь остановимся на числе пройденных за обучение токенов. В LLaMa-моделях это значение варьируется от 1T до 2Т. Ниже приведены основные параметры по числу размерности внутренних эмбедингов, числу голов Attention, слоёв и параметров обучения разных моделей:



ссылка на источник картинки


Архитектура
У LLaMa-моделей предлагается целый ряд архитектурных изменений. Так как в учебнике рассматривался лишь базовая архитектура трансформеров, то опишем, что в ней необходимо изменить, чтобы получить LLaMa-модель.


Pre-нормализация.



Обычно используется LayerNorm, а в LLaMa — RMSNorm.


Пусть   Тогда нелинейное преобразование в общем виде выглядит так:
И LayerNorm можно описать следующими формулами:
В свою очередь экспериментально RMSNorm демонстрирует лучшие результаты в сравнении с  LayerNorm и высчитывается так:


SwiGLU-активация используется вместо ReLU.  — значок поэлементного умножения матриц.


Роторные эмбединги. Информацию о том, в каком порядке следуют токены внутри модели, хранят в себе позиционные эмбединги. Они могут быть абсолютными (кодирование синусами и косинусами, как описано в параграфе о трансформерах) или относительными (кодируется расстояние между каждой парой токенов).
Роторные эмбединги позволяют вычислять относительную связь между парой токенов на этапе вычисления Attention, также они выигрывают по сравнению с относительными в совместимости kernel-ов. То есть, одно из понятных не технических отличий их от других — вычисление позиционной информации на каждом слое модели при подсчёте Attention, а не только перед первым слоем. Это позволяет на каждом слое явно обрабатывать информацию об относительном расположении токенов. Роторные эмбединги показывают лучшее качество на многих задачах и являются стандартом для обучения языковых моделей. Подробнее о них можно почитать в этой статье.


Существуют также техники ускорения обучения моделей и оптимизации использования памяти, но с этим предлагаем читателям ознакомиться самостоятельно.
SFT (supervised finetuning)SFT (supervised finetuning)
Второй этап обучения инструкционных языковых моделей требует множество инструкций. Рецепт как их готовить был подробно описан в середине этого параграфа. Снова проговорим, что для написания инструкций или сбора датасета необходимо, чтобы инструкции были:

разнообразными;
качественными;
имели одинаковый формат, чтобы чатовая модель могла обучиться диалоговости (где вопрос пользователя, где ее ответ);
информативными;
подробными;
Chain-of-Thought (CoT), few-shot и так далее.

Reward-модельReward-модель
Третий этап в создании инструкционных моделей. Есть несколько способов собрать датасет для обучения reward-модели. Он должен содержать тексты и метки к ним. Если меток много (например, в случае балльной оценки), можно использовать разновидности ранжирующих лоссов. Разберем способ обучения модели на бинарную оценку.
Пусть модели подается на вход инструкция . Поменяв температуру, способ сэмплирования или использовав разные чек-пойнты модели, возможно получить два разнообразных ответа  и . Не ограничивая общность, предположим, что, согласно некоторым предпочтениям, асессоры или пользователи установили, что первый ответ лучше второго.
Проделаем эту операцию много раз и получим обучающее множество, состоящее из . Тогда reward-модель можно обучать минимизацией следующей функции потерь:
Где:
  — reward-модель с обучаемыми параметрами тета;
 — некий margin, который определяет, насколько сильно модель должна отделять хороший и плохой ответы друг от друга.
RL (Reinforcement Learning)RL (Reinforcement Learning)
На четвёртом этапе, этапе выравнивания модели, можно воспользоваться разными алгоритмами. LLaMa-2 Chat была обучена последовательно сначала на Rejection Sampling fine-tuning (RL «для бедных») и Proximal Policy Optimization (PPO).
Rejection Sampling fine-tuning. Этот подход основан на довольно простой стратегии. Пусть имеется инструкция . Сгенерируем для неё  ответов и выберем тот, который получает наивысшую оценку у reward-модели. График ниже демонстрирует, что чем больше , тем больше reward-score у лучшего ответа. Собрав пары инструкция — лучший ответ, можно обучить на них языковую модель и провести таким образом выравнивание поведения модели.



ссылка на источник картинки


Proximal Policy Optimization. Для лучшего понимания происходящего советуем прочесть параграф, посвященный RL.
Основная задача, как обычно, следовать некой политике, которая лучшим образом отражает human feedback. Политика — наша итоговая модель, value-функция оценивает средний reward в текущем состоянии (обычно это та же самая модель с линейным слоем поверх).
Формализуем термины из RL для задачи выравнивания языковой модели:

Политика  — обучаемая языковая модель.
Value-функция  — обычно та же самая модель с линейным слоем поверх, оценивает средний reward, если действовать из состояния  согласно политике .
 — состояние в момент времени . Это весь контекст -токенов, которые модель успела сгенерировать к текущему моменту.
 — действие из текущего состояния в момент времени . Обозначает следующий токен, который будет сгенерирован.
 — траектория, т. е. тройки , — это состояния генерируемого токена и награды за него

Сразу можно сделать вывод, что в языковых моделях , 
Также, в RL символом  обозначается вся последовательность токенов, то есть на практике сюда можно подставлять количество сгенерированных токенов.
Инициализируем  — начальные веса политики и value-функции
Для 


Соберем коллекцию траекторий  , следуя политике .


Посчитаем . Эта формула отражает разницу между финальной наградой за выбранное действие  в текущем состоянии  и средней финальной наградой, которую можно было бы получить в этом состоянии. Вообще говоря, с помощью метода Generalized Advantage Estimation (GAE) её можно аппроксимировать следующим выражением:


Обновляем веса политики согласно одному из лоссов PPO. Например, используем такой:


С помощью MSE лосса оптимизируем значение value-функции:


ИтогИтог
Мы с вами обсудили, как развивались языковые модели, какие приёмы и техники необходимы для успешного обучения инструкционных моделей. Также на примере архитектуры LLaMa разобрали, как самостоятельно обучить языковые модели с нуля.

