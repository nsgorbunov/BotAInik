ВведениеВведение
Все рекомендательные системы можно поделить на три типа в зависимости от того, какую информацию они используют для построения рекомендаций:

Контентные;
Коллаборативые;
Гибридные.

В данном разделе мы подробнее рассмотрим основные алгоритмы построения контентных рекомендаций.
Основная идея контентных рекомендаций состоит в том, что для их построения будут использоваться атрибуты объектов и пользователей. На основе данных атрибутов мы можем найти релевантные данному пользователю объекты и рекомендовать их.
Представим, например, что мы работаем в музыкальном онлайн-сервисе и хотим подбирать наиболее релевантную музыку нашим пользователям. Допустим у нас есть пользователь Иван, который интересуется русским роком. Тогда наша система может рекомендовать Ивану музыку этого или подобных жанров.
Можно придумать много различных атрибутов трека: жанр, автор, год выхода, продолжительность и так далее. Также можно использовать дополнительную информацию о пользователе: возраст, уровень дохода и тому подобные.
Какими бывают контентные признакиКакими бывают контентные признаки
Допустим, мы работаем в музыкальном сервисе. Тогда в качестве признаков объектов можно использовать:

Стандартные статистики объекта: количество лайков, кликов, полных прослушиваний;
Признаки автора: количество слушателей, жанр;
Неструктурированные данные: названия треков, обложки альбомов или даже предобученные эмбеддинги треков целиком.

В качестве признаков пользователей можно использовать:

Информацию про пользователя, если она нам доступна: возраст, пол, язык, насколько долго пользуется сервисом;
Информацию про контекст запроса: с какого устройства был сделан, в какое время.
Информацию про друзей пользователя и их взаимодействия. Например, усреднённый эмбеддинг всех треков, которые слушал каждый из друзей. Или же можно обучить RNN или Transformer на истории и результат конкатенировать к остальным признакам.

Факторизационные машиныФакторизационные машины
Начнём с постановки задачи. Пусть I – множество объектов (айтемов), U - множество пользователей. Для каждой пары объект-пользователь построим вектор размерности  взаимодействия этой пары, в котором единицы стоят на месте соответствующих пользователя и объекта:

Предсказывать будем пользовательские рейтинги объектов .
Можно рассмотреть простейшую регрессионную модель:
Заметим, что к этой модели легко добавить любые фичи объектов, пользователей или пар объект-пользователь:

Дальше будем обозначать через  общее число фичей. Модель можно обогатить признаками, отвечающими за взаимодействия второго порядка:
Матрицу  можно считать симметричной: в любом случае, мы используем только её верхний треугольник.
Из-за использования попарных взаимодействий пользователей и объектов в полученной модели будет  параметр, и так как  может быть очень большим, работать с такой моделью может оказаться непросто.
Для решения этой проблемы можно использовать следующий трюк. Сопоставим каждому признаку  вектор  для некоторого не очень большого  и представим модель в виде:
Таким образом, мы заменяем симметричную матрицу коэффициентов  на её низкоранговое приближение , где  – матрица  с векторами  по столбцам. Число параметров модели при этом можно снизить до . На практике матрица  разреженная, и, как правило, даже при небольшом  получается её неплохо приблизить. В то же время, при небольших  модель обладает лучшей обобщающей способностью.
Вычислить  по можно за :
Итоговая модель имеет вид
Данная модель и называется факторизационной машиной.
Первоначально факторизационные машины использовали только коллаборативный сигнал, но, как мы уже видели, в такую модель можно естественным образом добавить и контентную информацию.
Факторизацонную машину можно обучать для решения разных задач. Например:

Предсказание рейтинга. Ответ модели  можно интерпретировать, как вещественный рейтинг, и решать задачу регрессии.
Бинарную классификацию рекомендовать/не рекомендовать. Тогда  имеет смысл логита, и мы можем оптимизировать оптимизировать log loss или hinge loss.
Ранжирование объектов. Тогда  – это ранжирующая функция.

Модель обычно обучается градиентным спуском.
FFM – Field-aware Factorization MachinesFFM – Field-aware Factorization Machines
Оригинальная статья
Статья про практическое применение
Как следующий этап развития факториационных машин, появилась идея иметь несколько различных латентных представлений для каждой из фичей.
Пример: есть три разных по своей природе признака: год выпуска, цвет и марка автомобиля. В факторизационной машине для учёта взаимодействия год-цвет и год-марка используется один и тот же вектор для года. Но так как эти признаки разные по смыслу, то и характер их взаимодействия может отличаться.
Идея: использовать 2 разных вектора для признака «год выпуска» при учёте взаимодействий год-цвет и год-марка. Таким образом, модель принимает вид:

Авторы статьи выложили исходный код своей библиотеки libffm, с помощью которой они смогли войти в топ-3 сразу в трёх соревнованиях на kaggle (Criteo, Avazu, Outbrain). Подробнее об этом можно почитать вот тут.
DSSM (deep sematic similiarity model)DSSM (deep sematic similiarity model)
Теперь рассмотрим ещё одну популярную модель, которая использует контентную информацию для построения рекомендаций – DSSM.
Оригинальная статья
В оригинальной статье DSSM была использована для нахождения «схожести» между поисковым запросом и документом. Для этого она использовала текст запроса и текст документа.
DSSM представляет из себя «двуногую» (two-tower) нейронную сеть. В исходной постановке на первый вход подаётся текст запроса, а на второй – текст документа. Далее, независимо для текста запроса и текста документа строятся эмбеддинги. Итоговая «схожесть» вычисляется, как косинусная мера близости между ними.
На схеме ниже Q – это запрос (query), а D – документ (document).

Некоторые авторы пытались в качестве меры близости рассматривать вместо косинусной меры обучаемый MLP, но это оказалось гиблой идеей.
Эта архитектура оказалась крайне удобной при использовании на практике, так как эмбеддинги пользователя и объекта можно предподсчитать независимо и дальше хранить сразу готовые представления для них, а при запросе к рекомендациям просто пересчитывать меру близости, что ускоряет применение модели.
Данная идея хорошо обобщается на построение рекомендаций. Поиск релевантных объектов можно представить, как задачу ранжирования, где вместо текстов запроса и документа мы будем иметь некоторую контентную информацию о пользователе и объекте.
Обучение DSSMОбучение DSSM
Давайте считать, что мы для каждого запроса  предсказываем один релевантный документ.
Обозначим через  и  построенные моделью эмбеддинги запроса  и документа  соответственно. Будем вычислять условную вероятность клика по документу  при условии запроса  следующим образом:
где
Здесь  – коэффициент сглаживания, который подбирается эмпирически, а  – число всех документов.
Если в качестве функции потерь мы выбираем кросс-энтропию, то на паре запрос-кликнутый документ  она принимает вид
Но вычислять градиент такого функционала для каждого примера дорого, ведь для этого придётся для каждого запроса находить вероятность клика по всем документам. Что же делать? На помощь приходит negative sampling. Заметим, что среди документов  в знаменателе  есть лишь один кликнутый, а остальные тысячи и миллионы являются отрицательными примерами. Есть смысл на каждом шаге оптимизации рассматривать не все из них, а только небольшую выборку, вместо полной суммы
беря
где  – подобранные для запроса  негативные примеры. Генерировать их можно по-разному; на практике чаще всего используют одну из следующих стратегий:

Равновероятно выбирать подмножество документов из некликнутых. В оригинальной статье предлагают брать позитивные и негативные в соотношении .
С большей вероятностью выбирать те из некликнутых документов, популярность которых выше.
На каждой эпохе обучения выбирать некликнутые документы, получившие максимальный скор для этого запроса на предыдущей эпохе.

Другие функции потерьДругие функции потерь
Pairwise lossPairwise loss
Задачу построения рекомендаций можно решать, как задачу ранжирования. Например, это можно делать с помощью попарного лосса. А именно, рассмотрим пару объектов, в которой  – релевантный, а  не релевантный для пользователя . Тогда мы можем использовать один из двух вариантов функции потерь:


. Тем самым модель будет учиться ранжировать положительные примеры выше отрицательных.


 (triplet loss). При этом модель обучается так, чтобы положительный и отрицательный примеры как можно больше отличались. Эта функция потерь довольно популярна не только в DSSM сетках, но и в целом в задачах, где нужно обучить парные представления  объектов  из разных доменов так, чтобы для релевантных друг другу  и  эмбеддинги оказывались близкими, а для не релевантных далёкими.


Full Product Softmax lossFull Product Softmax loss
Рассмотрим батч  размера , где  – пользователь,  – пользователю, а  – таргет, степень релевантности объекта пользователю. Построим по ним:

матрицу эмбеддингов пользователей ;
матрицу эмбеддингов объектов ;
вектор таргетов .

Рассмотрим матрицу
где softmax берётся по строкам

Рассмотрим функцию потерь вид
Эта функция потерь старается сделать так, чтобы для релевантных друг другу (с ) пар  скалярное произведение эмбеддингов  было максимальным.
Трансформеры для рекомендацийТрансформеры для рекомендаций
В 2018 году появилась архитектура трансформеров на основе механизма внимания. Модели на основе трансформеров показали state-of-the-art результаты на большом числе NLP задач, а впоследствии оказалось, что они отлично подходят и для задач компьютерного зрения. С их помощью можно решать и задачи рекомендаций. Аналогия заключается в следующем: если в NLP трансформеры работают с последовательностями токенов, то в рекомендациях в качестве последовательности можно взять историю событий пользователя. Каждый элемент последовательности – это взаимодействие пользователя с объектом, например, клик на объект.
Классические модели рекомендаций часто игнорируют тот факт, что история пользователя – это направленная последовательность, в которой порядок событий имеет значение. Трансформеры позволяют учитывать как порядок событий, так и сложные паттерны в поведении и интересах пользователя. Например, исследователи из Alibaba представили модель, которую назвали Behaviour Sequence Transformer. Авторы заявляют, что модель используется в продакшене. Модель решает задачу Click Through Rate (CTR) prediction – предсказание вероятности клика по объекту.

На вход модели подается история кликов пользователя, на основе которой нужно предсказать вероятность клика по заданному объекту. Роль архитектуры трансформера здесь в том, чтобы качественно закодировать представление пользователя, после чего применяется обычный multi layer perceptron (MLP) для предсказания вероятности.
Помимо архитектур, которые специально разрабатываются под задачи рекомендаций, трансформеры можно использовать и как обособленные предобученные модели для построения векторых представлений текстов или изображений, которые затем подаются как признаки для решения downstream задач в домене рекомендаций. Несмотря на очевидные преимущества трансформеров с точки зрения качества, их использование в продакшене часто ограничивается имеющимися вычислительными ресурсами. Это особенно актуально для рекомендаций, где модели важно применять непосредственно в момент запроса пользователя.

