Объекты, с которыми работает машинное обучение, очень разнообразны и часто состоят из большого количества низкоуровневых сигналов: это может быть цвет отдельного пикселя, амплитуда звукового сигнала в отдельно взятый момент времени или буква в тексте.
Каждый из таких слабых сигналов в отдельности несёт крайне мало информации про объект, но все вместе слабые сигналы складываются в музыку, изображение или текст.
В сыром виде такие объекты сложно анализировать, поэтому наша цель — находить хорошие представления данных, удобные для анализа и решения разных задач. Любой способ построения признакового описания объекта мы будем назвать алгоритмом построения представлений, а настройку такого алгоритма по данным — обучением.
Так, все методы понижения размерности, например, SVD — это методы обучения представлений, а методы обучения представлений часто можно проинтерпретировать как методы понижения размерности.
Представим, что нам хочется уметь искать похожие музыкальные треки и использовать эту технологию в музыкальном сервисе для функции «играть похожие треки».
Каждый трек в нашей базе хранится в формате WAV с частотой 44kHz и длится 3 минуты. Другими словами, трек будет описываться вектором из 7920000 чисел (44000 Hz * 60 секунд * 3 минуты).
Однако небольшие изменения треков (сдвиг по времени, изменение громкости) могут соответствовать существенному изменению положения вектора представлений в пространстве. Поэтому простые расстояния в таком пространстве, вероятно, не будут отражать представление людей о схожести треков. Искать похожие треки, используя такие, сырые представления, проблематично, и необходимо научится строить представления, с помощью которых будет удобно решать разные высокоуровневые задачи.
Выученные представления или модели для вычисления представлений можно использовать для:

Поиска изображений: по представлению изображения искать похожие изображения.
Рекомендаций: по представлениям пользователя определять наиболее интересные фильмы или товары.
Чат-ботов: по представлению диалога уметь продолжать диалог, отвечать на вопросы и так далее.
Систем видеосвязи: уметь восстанавливать кадры по компактным представлениям, сохраняя высокое качество картинки.
и многого другого.

Для каждой из этих задач будут свои хорошо отлаженные трюки, однако ключевых идей, которые часто переиспользуются, повторяются и модифицируются, не очень много. Мы постараемся рассказать про такие идеи.
Предупреждение: перед прочтением этой главы стоит освежить в памяти главу про
нейронные сети.
Нейронные сети и выучивания представленийНейронные сети и выучивания представлений
Нейронные сети можно рассматривать, как механизм автоматического выучивания представлений, поэтому современные методы выучивания представлений существенно сконцентрированы на использовании нейросетей.
Напомним, что нейронная сеть состоит из набора дифференцируемых преобразований, примененных друг за другом к объекту  для получения предсказания целевой переменной . Обычно преобразования содержат обучаемые параметры, которые настраиваются в процессе обучения по данным.
Преобразования в литературе часто называют слоями. Результат применения преобразования к его входу мы будем называть скрытыми представлениями или активациями.
RepresentationsRepresentations
Активации любого слоя можно использовать как представления объекта. Представления с разной глубины нейронной сети будут обладать разными свойствами.
Рассмотрим свёрточные нейронные сети для изображений. Активации первых слоёв обычно видят только маленькие части исходной картинки, другими словами, имеют маленький receptive field. Такие активации могут реагировать — принимать большие значения — только на низкоуровневые детали, маленькие фрагменты изображения.
По мере увеличения глубины receptive field становится больше, а активации начинают реагировать на более высокоуровневые абстракции, такие как формы и части объектов. Активации последних слоёв имеют большой receptive field и реагируют на уже на объекты и группы объектов.



Источник


На изображении ниже показаны части картинок (патчи), каждая группа из 9 изображений максимизирует значение определенной активации в обученной нейронной сети. Размер патча зависит от receptive field активации, а максимизация ведется по датасету реальных изображений:  выбираем топ-9 патчей из датасета по значению активации.
Для активаций, взятых с ранних слоев, нейроны реагируют на низкоуровневые детали. По мере увеличения глубины нейроны начинают реагировать на более высокоуровневые объекты.



Источник


Большая часть методов, которые мы рассмотрим ниже, за исключением матричной факторизации (в зависимости от того, как на это взглянуть), будут использовать активации нейросети в качестве представлений. Поэтому, обучить представления и обучить нейросеть это почти синонимы. Большинство отличий будет состоять в том, как эти нейронные сети обучаются и какую архитектуру имеют.
ДообучениеДообучение
Нейронные сети можно обучать из случайной инициализации, а можно стартовать с вектора весов, обученного на внешнем датасете.
К примеру, если вы решаете задачу классификации изображений, часто инициализация части вашей нейронной сети весами, предобученными на популярном датасете ImageNet, ускорит и улучшит обучение.
Такой процесс называется fine-tuning («дообучение» / «файнтюнинг»):



Источник


Как можно усложнять эту схему:

Добавлять в модель много новых, обучающихся с нуля слоёв (на картинке мы добавляем один, но можно и больше);
Не обязательно копировать все слои, можно копировать только сколько-то первых.
Дообучать как все веса модели, так и какую-то часть. К примеру, можно заморозить скопированные слои и дообучать только новые части модели.
Для файнтюнинга часто используют постепенное увеличение (warm-up) learning rate на первых эпохах обучения. Это позволяет сетке «привыкнуть» к новой задаче и архитектуре. Пример:




Источник


PriorPrior
В некотором смысле хорошая инициализация работает как праер на функции, которые могут быть выучены после дообучения.
Поэтому дообучение часто требует в разы меньше данных, чем обучение со случайной инициализации.
Supervised обучениеSupervised обучение
Обучение представлений через решение supervised задачиОбучение представлений через решение supervised задачи
Обучение представлений через решение supervised задач — это простой и популярный способ обучения представлений. Рассмотрим его на примере задачи поиска изображений (image retrieval)
Задача: Рассмотрим задачу поиска изображений. Каждое изображение хочется закодировать вектором признаков (представлением) так, чтобы вектора признаков похожих изображений были близки.
При чем тут обучение представлений? Image retrieval часто рассматривается как задача обучения представлений. Хочется получить алгоритм, который по изображению выдаст вектор (представление объекта) так, чтобы близость векторов по какой-то простой (скажем, евклидовой) метрике означала схожесть объектов.
Идея: Возьмём активации с последнего слоя из нейросети, предобученной на большом размеченном датасете.
Для задач зрения почти всегда имеется ввиду предобучение на задаче классификации. Также мы предполагаем, что высокоуровневая разметка собрана человеком.
Почему такие представления могут адекватно решать задачу поиска изображений? Классификационная сеть будет неявно поощрять, чтобы у похожих изображений векторы активаций тоже были близки. К примеру, перед последнем слоем классификационной сети активации кошек и собак должны быть распознаны линейными классификаторами — активации картинок одного класса должны быть близки друг к другу. А за счет похожих паттернов визуально похожие коты будут находиться ближе друг к другу, чем непохожие.
РешениеРешение
Для начала нам нужно обучить нейросеть на большом размеченном датасете картинок/текста/звука/... (pretext problem)
Обычно лучше всего работает предобучение на задачах классификации. Почему так происходит? Пока непонятно. Возможно, это связано с тем, что для классификации удобнее собирать датасеты, а возможно это хорошие свойства задачи или CrossEntropy функции потерь.

Для изображений часто используется предобучение на датасете ImageNet — классификация на 1000 классов, 1.3M изображений в обучающей выборке, ~ 150 GiB.
Для текстов, обычно решают задачу языкового моделирования, на набирающем популярность датасет The Pile ~ 825 GiB.

Затем мы дообучаем нейросеть на более похожем на нашу задачу размеченном датасете  (если такой есть; если нет пропускаем этот шаг).
После — оставляем только первые  слоёв. Aктивации слоя  берём в качестве представлений объектов
Агрегируем активации по пространственным координатам, чтобы получить вектор для каждого объекта. Часто используется покомпонентное среднее или максимум (скажем, глобальный пулинг для изображений).
Наконец, используем признаки или предобученные веса для решения целевой задачи (downstream problem).
Об алгоритмеОб алгоритме
Supervised подход можно применять для различных типов данных. Всё, что нужно — это большой размеченный датасет, хоть и отдалённо, но похожий на целевые данные. Для музыки это может быть задача классификации жанра, для видео — задача классификация действий, для текста — классификация тематик.
Достоинства и недостаткиДостоинства и недостатки
👍 Благодаря выученным представлениям мы сможем решать целевую задачу, не имея для неё большого датасета;
👎 Нужен большой размеченный датасет, близкий для целевой задачи;
👎 Оптимальные представления для датасета, на котором мы предобучаемся, могут сколь угодно плохо подойти для целевой задачи. К примеру, представления, полученные на ImageNet, плохо подойдут для медицинских изображений (Raghu2019).
ЭкспериментыЭксперименты
На рисунке ниже показан пример того, как представления помогают решать задачу поиска. Запрос находится в самом левом столбике. Зеленым отмечены верно найденные изображения, красным — неверно найденные, синим — изображения из стоп-листа.
Как видно, система вполне неплохо решает задачу поиска изображений. Подробнее про такой подход для поиска изображений можно почитать в работах  (Babenko 2014, Babenko 2015).



Источник


СоветыСоветы
Статья Big Transfer (BiT): General Visual Representation Learning (Kolesnikov at el. 2019) даёт ряд важных советов, о том, на что именно стоит обратить внимание при supervised обучении c целью переноса представлений и весов модели на новые задачи.
Рассмотрим их подробнее.


Большие и разнообразные датасеты: Увеличение размера pretex-датасета вносит существенный вклад в качество решения downstream задачи. Авторы продемонстрировали, что при предобучении переход от 1М изображений (ImageNet) к 14М изображений (ImageNet21k) к 300M изображений (JFT), стабильно улучшает качество дообучения на новой задаче с маленьким числом размеченных примеров. Да, тут мы заходим на территорию, когда ImageNet рассматривается как маленький датасет.


Большие pretext модели: Увеличение датасета при недостаточном размере модели может навредить. Нужно одновременно иметь большие модели и большие датасеты. Одно из возможных объяснений такое: с увеличением датасета модель должна предсказывать правильные ответы на трейне для огромного числа точек. При этом нельзя работать очень плохо хоть на каких-то точках, ведь когда гибкости недостаточно, моделька настраивается «так себе» во многих областях пространства, что может ухудшить финальное качество алгоритма.


Долгое обучение: Большие модели требуют много шагов оптимизации.


ОговоркаБольшие модели часто учатся на десятках, сотнях или даже тысячах вычислителей, таких как GPU и TPU, и требуют много памяти для обучения. Как правило, это происходит из-за большого размера моделей: на один вычислитель часто помещаются только маленькие минибатчи (1-10 примеров). Маленькие минибатчи работают плохо с популярной Batch Normalization или требуют дорогой синхорнизации между вычислителями.
В статье (Kolesnikov at el. 2019) Batch Normalization заменяется на Group Normalization, которая позволяет использовать батчи маленького размера на каждом отдельном вычислительном девайсе. Group Normalization  используется в комбинации c  Weight Standardization , что позволяет улучшить обучение.
Обучение метрических эмбедингов с использование разметки (triplet loss)Обучение метрических эмбедингов с использование разметки (triplet loss)
Мотивация: После supervised обучения расстояния между эмбеддингами не обязаны хорошо отражать треубуемую для решения нашей задачи «похожесть». Поэтому хочется, чтобы «похожесть» моделировалась известным расстоянием (к примеру евклидовым).
Для этого была предложена триплетная фунция потерь или triplet loss (Schroff at el. 2015). Триплетный лосс обучается на тройках объектов (якорный объект, негативный к якорному, позитивный к якорному). Информация о позитивных и негативных объектах – это один из видов разметки. Этот лосс может использоваться как для обучения с нуля, так и для дообучения.
Отметим, что объекты не обязательно должны быть из одного домена: к примеру, якорный объект может быть картинкой, а позитивные и негативые объекты текстами. Таким образом, мы сможем находить «подходящие» тексты к картинкам и наоборот.
Как будет устроено обучениеКак будет устроено обучение

рассмотрим тройки объектов , где  — позитивный пример к ,  — негативный пример к 
будем притягивать  и  и отталкивать  и 
одним из популярных лоссов для решения такой задачи является triplet loss:


 представляется нейронной сетью 
 — параметер зазора — в некотором смысле усложняет задачу:

при  достаточно, чтобы позитивный эмбединг был ближе якорному, чем негативный;
с параметром  мы начинаем требовать, чтобы позитивный был ближе, чем негативный, как минимум на .


лосс  оптимизируем по параметрам .


Почему бы просто не притягивать позитивные примеры? Нужны ли нам негативные?Если будем только притягивать, то любой константный вектор будет хорошим решением. К примеру .
Алгоритм формирования троекАлгоритм формирования троек
Обучение с триплет лоссом сильно зависит от алгоритма формирования троек.
Если формировать тройки случайно, то большинство троек будут слишком легкими, не информативными. Негативные объекты будет слишком легко отличить от позитивных, поэтому обучающего сигнала от таких троек будет мало.
Поэтому хочется собрать наиболее сложные тройки из всех объектов в датасете или минибатче.
Такой процесс называется hard negative/positive mining и часто используется для обучения с триплетной функцией потерь.
🧪 Примеры:
ПримерыПримеры

Диалоговая система:

 — фраза;
 — подходящий ответ;
 — ответ не в тему.


Верификация лица:

 — лицо которое хотим верифицировать;
 — тот же человек, что и в , но с других ракукрсов, в другом освещении, ...;
 — лица других людей.




Достоинства и недостаткиДостоинства и недостатки
👍 Обучение метрических эмбедингов (metric learning), в отличие от supervised подхода, использует информацию о метрике, что позволяет выучить более релевантные представления для целевой задачи.
👎 Все еще требует разметки (на тройки объектов).
👎 Обучение с триплетным лоссом часто ведет себя нестабильно (еще нестабильнее, чем обучение нейросетей для других задач).
Self-supervised обучениеSelf-supervised обучение
В этом разделе мы хотим показать, что нейронные сети и представления можно предобучать без рукотвороной разметки.
Мотивация Мы разобрали supervised предобучение нейронных сетей и их использование для извлечения признаков. Однако supervised подходы не всегда эффективны. Supervised обучение требует больших размеченных датасетов.
Разметка данных — это трудоёмкий и дорогой процесс, на выходе от которого всё равно получается шумная, и зачастую смещенная разметка. Поэтому от ручной разметки данных хочется уйти или хотя бы постараться её минимизировать.
Этого можно добиться, если научиться использовать неразмеченные данные для предобучения. Неразмеченные данные генерируются в огромном количестве, и их значительно проще собирать. Это позволит нам обучаться на  огромных коллекциях данных, размер которых был бы недостижим при необходимости сбора разметки.
Также в каждом объекте, изображении, звуке или тексте содержится в разы больше информации, которую можно учитывать при обучении, чем закодировано в одном таргете.
К примеру, один из тысячи классов можно закодировать всего десятью битами, а изображение содержит мегабайты внутренней полезной информации, котрую можно использовать для обучения. Поэтому подходы, которые могут обучаться без разметки, но с использованием внтурненнией информации, потенциально могут выучивать более хорошие представления, чем supervised подходы.
💡Основная идея self-supervised обучения — обучение через решение синтетических supervised задач (pretext problems), источником разметки в которых является сам объект (текст, изображение, или видео). Отсюда и приставка "self" в названии подхода.
Примеры pretext задачПримеры pretext задач

предсказание объекта по его компактному описанию;
предсказание слова по контексту;
предсказание закрытой части изображения по открытой;
предсказание будущих кадров по прошлым.

Если всё это кажется вам supervised-задачами, вы правы! Приставлка self- означает отсутствие внешней разметки.
Признаки и веса, выученные для решения, казалось бы, бесполезных pretext задач, на практике работают как очень хороший претрейнинг для решения supervised задач (downstream problems). Это позволяет достигать отличного качества, используя в сотни раз меньше размеченных данных по сравнению с чисто supervised подходами.
Осталось ответить на вопрос: какие pretext задачи использовать?
Универсального ответа нет, но оказывается, что многие pretext задачи используют контекст для обучения. Подробнее об этом расскажем далее.
Использование контекста для обученияИспользование контекста для обучения
Почему контекст так важен для обучения? Обучение людей, как и обучение алгоритмов, неразрывно связано с использованием контекста.
При изучении иностранного языка часто прибегают к упражнениям вида «Вставте правильные слова в текст». Чтобы выполнить такое упражнение, человеку нужно учитывать контекст и предсказывать значения незнакомых слов, если это необходимо для понимания текста.

Предложенная профессором Южно-Калифорнийского университета Стивином Крашенйном «гипотезы входного материала» (input hypothesis) предполагают, что для эффективного изучения языка человеку нужно читать и слушать текст, который немного превышает его текущий уровень. Скажем, содержит 10-15% незнакомых слов, но при этом остается понятным. Такой способ обучения требует восстановления значения незнакомых слов из контекста.
Визуальный контекст также широко используется при обучении детей. Вы можете помнить упражнения, в которых нужно было найти лишний предмет, закончить рисунок или раскрасить изображение. Такие задания требуют учета визуального контекста для решения задачи: важно уметь понимать принадлежность разных рисунков к одной группе, генерировать изображение, наблюдая только некоторую его часть и так далее.

Self-supervised обучение представлений и моделей глубокого обучения использует похожие идеи обучения из контекста.
К примеру, модель  word2vec (Mikolov et al. 2013) и BERT (Devlin et al. 2018) выучивают эмбединги слов, решая задачу предсказания слов по контексту. С философией word2vec вы уже познакомились в параграфе про нейросети для работы с последовательностями.
А некоторые модели для картинок решают пазлы (Doersch, Noroozi et al. 2017), дополняют изображения или звуки (van den Oord et al. 2018), раскрашивают фотографии (Zhang et al. 2016) и ищут похожие объекты (Chen et al. 2020).
Последнюю из них — SimCLR – мы подробно разберём ниже.
Self-supervised предобучение для изображенийSelf-supervised предобучение для изображений
SimCLR — метод, который первым продемонстрировал, что self-supervised предобучение может достигать того же качества что и supervised обучение.
Он основан на контрастивной функции потерь (contrastive loss), и в некотором смысле решает задачу поиска похожих объектов.
Также мы разберем метод self-supervised предобучения для vision tranformer, который, в некотором смысле, дорисовывает картинку, а также демонстрирует, что методы self-supervised предобучения для изображений и текстов во многом похожи.
Стоит отметить, что pretext задачи, которые мы будем обсуждать ниже, не являются «серебряной пулей».
Известно, что такие задачи работают как хороший претрейнинг. Другими словами, позволяют получить хорошее качество для некоторых downstream задач (классификация, детекция, сегментация) после дообучения на небольшом количестве размеченных примеров.
Хорошего понимания, почему эти методы работают, в области пока нет. Скорее всего, разные типы задач (downstream problems) будут требовать разных методов претрейнинга, но это мы поймём только в ближайшие несколько лет.
A Simple Framework for Contrastive Learning of Visual Representations (SimCLR)A Simple Framework for Contrastive Learning of Visual Representations (SimCLR)
SimCLR решает синтетическую задачу поиска похожих  изображений. Вот как он работает на верхнем уровне:

Для каждого изображения в минибатче генерируются две аугментации;
Выбирается одно из изображений; одна из его аугментаций считается запросом, вторая — позитивным ответом, аугментации остальных объектов — негативными примерами;
Цель модели — для каждого «запроса» найти позитивный пример.
Выученные веса могут быть использованны для «дообучения»/«файнтюнинга» сети под финальную задачу.




    Иллюстрация задачи SimCLR для одного запросса из минибатча
  

А вот как работает SimCLR на низком уровне


Источник


ЛоссЛосс
SimCLR оптимизирует контрастив лосс (contrastive loss), который фактически является кросс энтропией на positive-negative разметке:
где  — это косинусное расстояние, a лосс  работает следующим образом:

Контрастивная функция потерь  притягивает друг к другу эмбединги запроса  и позитивного примера , в то же самое время отталкивая эмбединги негативных примеров ;
Максимум  будет достигается в точке , поэтому эмбединги аугментаций одной и той же картинки будут притягиваться;
Знаменатель требует, чтобы негативные эмбединги были далеко от запроса.

Интуиция: На контрастивную функцию потерь можно смотреть как на поиск ответа по запросу, который ведется только среди всех эмбедингов в текущем минибатче. Такая задача требует сохранения информации про контент на изображении (что, вообще говоря, не очень просто) и в то же время понижения размерности, так как эмбединги  обычно имеют сравнительно низкую размерность.
Размер минибатча: Размер минибатча влияет на количество отрицательных примеров. Чем больше отрицательных примеров — тем более сложную задачу мы ставим перед нейросетью. Существует некоторый баланс между сложностью задачи и качеством выученных представлений. Слишком простые задачи (то есть маленькие батчи) обычно не позволяют выучить хороших представлений: простая задача может хорошо решаться даже с помощью «плохих» представлений. Поэтому SimCLR обучается хорошо только на очень больших мини-батчах (с тысячами примеров).
Что нам нужно иметь перед началом обученияЧто нам нужно иметь перед началом обучения

неразмеченный датасет изображений 
операцию аугментации изображения 
энкодер  (типичные значения M~2048)
проекция   (типичные значения K~128)

✍️ В примере сверху 
Как мы обучаемсяКак мы обучаемся


Семплируем мини-батч объектов ;


Для каждого объекта в минибатче :
— Cемплируем две аугментации ;
— Вычисляем эмбединги ;
— Вычисляем проекции  ;


Вычисляем contrastive loss , используя .
— В  два слагаемых из-за того, что в паре (изображение, аугментация), вообще говоря, любой элемент можно выбрать в качестве запроса (другой тогда будет позитивным примером). Тем самым из одного мини-батча картинок мы можем сделать два мини-батча для обучения SimCLR.
— Функция потерь  вычисляется для низкоразмерных проекций .


Делаем шаг по градиенту , повторяем с шага 1 пока не сойдёмся;


Используем  для генерации эмбедингов или файнтюнинга под supervised задачу.


Почему это вообще работает?Почему это вообще работает?
Точно никто не знает, но приведем следующую гипотезу:
Контрастивная функция потерь требует различать аугментации разных изображений. При этом эмбеддинги должны содержать информацию о контенте изображения, чтобы осуществлять поиск аугментаций одинаковых изображений по ключу. Этот процесс позволяет создать представления изображений, сохраняющие достаточно много информации про контент, чтобы решать не только задачу поиска аугментаций, но и другие задачи.
РезультатыРезультаты
Претрейнинг, который мы обсудили выше, позволяет эффективно дообучать модели и получать качество, сравнимое с supervised обучением, используя в 100 раз меньше размеченных примеров.

Оговорка в том, что эти результаты получены второй весрсией метода SimCLRv2 (Chen at. el, 2020).
SimCLRv2 TLDR; модели больше, глубже сеть проекции, улучшение качества происходит за счет дистиляции.
Немного вопросов и ответов про SimCLRКакие аугментации выбрать?
Авторы предлагают использовать resize random crop, random flip, color distortions, Gaussian blur. Такая комбинация была найдена небольшим перебором. Для разных данных оптимальный набор аугментаций может получаться разным.

Сложно ли такое учится?
Да, но сложности в основном технические. Вы быстро оказываетесь наедине c размером батча 2048 на ImageNet (не забудьте ещё, что на каждую картинку 2 аугментации, поэтому реальный размер батча 4048). Даже с не самой большой сеткой, например, ResNet50 (25М параметров) приходится использовать не один десяток ГПУ с 32 Гб памяти в каждой и долго ждать, пока всё обучится. Процесс чтения 2k картинок с диска тоже может занимать намного больше времени, чем вы предпологали, а одновременное вычисление 4k аугментаций быстро создает bottleneck в CPU. Но если у вас много GPU, батч успевает грузиться быстро, и аугментации не упираются в CPU, так что основные сложности позади.
Можно ли обойтись без contrastive loss/негативных примеров?
Да можно: так делают авторы статьи "Bootstrap your own latent: A new approach to self-supervised Learning" (Grill et al.). Но пока метод достаточно новый, и его рано добавлять в учебник. Если вам очень хочется узнать про этот метод, рекомендуем посмотреть разбор с анализом на канале Yannic Kilcher.
Vision Transformer и BERT-like обучениеVision Transformer и BERT-like обучение
Одна из самых популярных self-supervised задач в NLP — это предсказание замаскированных токенов (masked tokens prediction Devlin at el. 2019). При обучении такая модель (обычно transformer) видит текст, в котором некоторые токены заменены на специальный токен [MASK]; задача модели — правильно предсказать замаскированные токены по контексту.
Оказывается, такой претрейнинг позволяет очень хорошо адаптировать модель для решения разных задач, таких как классификация текстов, используя при этом мало размеченных примеров.
ОговоркаНа самом деле, модель будет способна не только предсказывать замаскированные токены, но и для оригинальных предсказывать «более логичные», на её взгляд замены: например, с её помощью можно исправлять опечатки. Это можно использовать на этапе обучения модели, чтобы показывать ей, что токена [MASK] может и не быть в тексте. Это может оказаться полезным на этапе файнтюнинга, где уже нет маскировки токенов.
Подробнее про Transformer, BERT, и masked tokens prediction можно прочитать в курсе NLP for You.
Можно ли использовать такой self-supervised подход для изображений? Оказывается, что да! В этом помогает vision transformer.
В последнее время модели на основе vision transformer (ViT) (Dosovitskiy at el. 2020) бурно развиваются и  компьютерного зрения.

В supervised режиме для задачи классификации vision transformer обучается следующим образом:

Изображение нарезается на квадратные патчи одинакового размера;
Затем патчи вытягиваются в последовательность;
Каждый патч вытягивается в столбец пикселей;
Каждый стобец проецируется обучаемой матрицей;
К каждому вектору с шага 4 добавляются positional encoding (без позиционных эмбеддингов трансформер не учитывает позицию токена в последовательности, а positional encoding кодирует позицию токена и позволяют трансформеру учитывать эту информацию);
Векторы с шага 5 подаются в трансформер;
Классификационный токен на выходе предсказывает распределение на классы;
Вычисляется кросс-энтропия, делается шаг по её градиенту.

ViT не используют локальные операции, такие как свёртки. Как следствие, такие модели требуют заметно больше данных и параметров для обучения (300M изображений по сравнению со стандартным размером размеченного датасета 1.3М). Но оказывается, что BERT-like self-supervised обучение применимо и для моделей vision transformer, и позволяет обучать их без использовния гиганских датасетов.
Какие self-supervised задачи на замаскированных патчах решают авторы статьи:

Предсказание среднего цвета в замаскированном патче;
Предсказание патча низкого разрешения и одновременное предсказание цвета;
Предсказание патча высокого разрешения разрешение с использованием -лосса.

Во всех случаях обучается и файнтюнится вся сеть целиком. Этот интересный пример показывает, что pretext-задачи придуманные, для NLP-сетей могут быть применены и к задачам зрения.
ПослесловиеПослесловие
Глубинное обучение — в существенной степени наука о представлениях сложных объектов. В этом параграфе мы лишь слегка затронули несколько важных тем: supervised предобучение, self-supervised предобучение, и metric learning. Self-supervised предобучение — это важный новый раздел глубинного обучения, который,  вероятно, поможет серьезно сократить количество необходимой разметки во многих приложениях. Генеративные модели VAE/inverse-GANs также широко используются для получения и обработки представлений. О них вы сможете прочитать в следующих параграфах.
Почитать по темеПочитать по теме

Contrastive Representation Learning, Lilian Weng, May 2021.
Self-Supervised Representation Learning, Lilian Weng, Nov 2019.
Самообучение (Self-Supervision), Александр Дьяконов, Июнь 2020.
Self-Supervised Learning | ICLR, Yann LeCun, May 2020.
Self-Supervised Learning | UC Berkeley, CS294-158 Deep Unsupervised Learning, Aravind Srinivas, Spring 2020.
Unsupervised Representation Learning | DeepMind x UCL.


